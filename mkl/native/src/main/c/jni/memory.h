#ifndef _MKL_MEMORY_H
#define _MKL_MEMORY_H

#include <jni.h>
#include <cstring>
#include <memory>
#include "MKLWrapper.h"
#include "debug.h"

template <typename DType>
class MKLData
{
 public:
  MKLData();
  ~MKLData();

  template <typename JArrayType, typename JType>
  friend class ZipArray;

  // set
  void createUsrLayout(int dimensions, size_t *size, size_t *stride);
  void createMklLayout(dnnPrimitive_t primitive, dnnResourceType_t type);
  /**
   * @brief create an mkl conversion
   *
   * @param doNotCreateConversion This argument is only for pooling. Because it
   *                              can't be converted when the mode is floor.
   */
  void createConversion(bool doNotCreateConversion = false);
  void backToUsr();
  // TODO If the input always the same, we should not have a set method.
  void setUsrData(void *ptr);
  // this is only for re-using previous layer memory.
  void setMklData(void *ptr);

  // get
  dnnLayout_t getUsrLayout();
  dnnLayout_t getMklLayout();

  // TODO should we combine this two versions of getData -> one version?
  void *getData();
  void *getConvertedData();

  // for debug
  void *getUsrData();
  void *getMklData();

  // for re-using output generated by mkl.
  bool isUseNext();
  bool isUsePrev();

  void setUseNext(bool val);
  void setUsePrev(bool val);
  // ------------------------------------

  // Currently, this two method substitude the backToUsr in pooling layer.
  /**
   * @brief cut the last row and column of every matrix in 4-D data.
   *
   * Note: MUST be used in mkl -> usr data.
   *
   * @param fromSize mkl data size.
   * @param fromStrides mkl data strides.
   * @param toStrides usr data strides.
   */
  void cutLastRowColumn(size_t *fromSize, size_t *fromStrides,
                        size_t *toStrides);
  /**
   * @brief pad the last row and column of every matrix in 4-D data.
   *
   * Note: MUST be used in usr -> mkl data.
   *
   * @param fromSize usr data size
   * @param fromStrides usr data strides
   * @param toSize mkl data size
   * @param toStrides mkl data strides
   */
  void padLastRowColumn(size_t *fromSize, size_t *fromStrides, size_t *toSize,
                        size_t *toStrides);

  size_t getMklLayoutSize();

 private:
  // call dnnAllocateBuffer to allocate a new block of mem
  void allocate();
  void convert(dnnPrimitive_t primitive, void *from, void *to);

  dnnLayout_t layoutUsr;
  dnnLayout_t layoutMkl;

  void *dataUsr;
  void *dataMkl;

  dnnPrimitive_t mklToUsr;
  dnnPrimitive_t usrToMkl;

  bool useNext;
  bool usePrev;
};

template <typename DType>
MKLData<DType>::MKLData()
{
  dataUsr = NULL;
  dataMkl = NULL;

  layoutUsr = NULL;
  layoutMkl = NULL;

  mklToUsr = NULL;
  usrToMkl = NULL;

  useNext = false;
  usePrev = false;
}

template <typename DType>
MKLData<DType>::~MKLData()
{
  if (layoutUsr) {
    dnnLayoutDelete<DType>(layoutUsr);
    layoutUsr = NULL;
  }
  if (layoutMkl) {
    dnnLayoutDelete<DType>(layoutMkl);
    layoutMkl = NULL;
  }
  if (dataMkl) {
    dnnReleaseBuffer<DType>(dataMkl);
    dataMkl = NULL;
  }

  dnnDelete<DType>(mklToUsr);
  dnnDelete<DType>(usrToMkl);

  LOG(DBG) << "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA";
}

template <typename DType>
void MKLData<DType>::createUsrLayout(int dimension, size_t *size,
                                     size_t *stride)
{
  dnnError_t status;
  status = dnnLayoutCreate<DType>(&layoutUsr, dimension, size, stride);
  CHECK_EQ(status, E_SUCCESS);
}

template <typename DType>
void MKLData<DType>::createMklLayout(dnnPrimitive_t primitive,
                                     dnnResourceType_t type)
{
  dnnError_t status;
  status = dnnLayoutCreateFromPrimitive<DType>(&layoutMkl, primitive, type);
  CHECK_EQ(status, E_SUCCESS);
}

template <typename DType>
void MKLData<DType>::createConversion(bool doNotCreateConversion)
{
  if (!layoutUsr && !layoutMkl) return;

  if (isUsePrev() || isUseNext()) return;

  // this->willToUsr = willToUsr;
  int isSame = dnnLayoutCompare<DType>(layoutUsr, layoutMkl);
  // it not unnecessary to convert when the layout in scala and mkl is the same.
  // But we shoud pay attention to that it's not sure layout must be the same
  // when the dnnLayoutGetMemorySize is the same.
  if (!isSame) {
    if (!dataMkl) {
      allocate();
    }

    if (!doNotCreateConversion) {
      if (mklToUsr) {
        dnnDelete<DType>(mklToUsr);
        mklToUsr = NULL;
      }
      if (usrToMkl) {
        dnnDelete<DType>(usrToMkl);
        usrToMkl = NULL;
      }
      dnnError_t status;
      status = dnnConversionCreate<DType>(&mklToUsr, layoutMkl, layoutUsr);
      CHECK_EQ(status, E_SUCCESS);

      status = dnnConversionCreate<DType>(&usrToMkl, layoutUsr, layoutMkl);
      CHECK_EQ(status, E_SUCCESS);
    }
  }
}

template <typename DType>
void MKLData<DType>::backToUsr()
{
  // TODO we should put the if statement of isUseNex here.
  if (dataUsr && dataMkl) {
    convert(mklToUsr, dataMkl, dataUsr);
  }
}

template <typename DType>
void MKLData<DType>::allocate()
{
  dnnError_t status;
  status = dnnAllocateBuffer<DType>(&dataMkl, layoutMkl);
  CHECK_EQ(status, E_SUCCESS);

  size_t size = dnnLayoutGetMemorySize<DType>(layoutMkl);
  memset(dataMkl, 0, size);

  LOG(INFO) << "Allocating layout memory -> " << size << " bytes...";
}

template <typename DType>
void MKLData<DType>::convert(dnnPrimitive_t primitive, void *from, void *to)
{
  dnnError_t status;
  void *resources[dnnResourceNumber];

  resources[dnnResourceFrom] = from;
  resources[dnnResourceTo]   = to;

  PERFSTART();
  status = dnnExecute<DType>(primitive, resources);
  CHECK_EQ(status, E_SUCCESS);
  PERFEND("main computing");
}

template <typename DType>
void *MKLData<DType>::getConvertedData()
{
  void *ret = dataUsr;

  // TODO something wrong
  // 1. The data of previous layer we use should be allocated by mkl
  // 2. Default it always convert the data.
  if (usrToMkl) {
    if (!isUsePrev() && !isUseNext()) {
      convert(usrToMkl, dataUsr, dataMkl);
    }
    ret = dataMkl;
  } else if (dataMkl) {
    // sometimes, we need create memory for mkl, like workspace in pooling.
    ret = dataMkl;
  }

  return ret;
}

template <typename DType>
void *MKLData<DType>::getData()
{
  void *ret = dataUsr;

  if (dataMkl) {
    // sometimes, we need create memory for mkl, like workspace in pooling.
    ret = dataMkl;
  }

  return ret;
}

template <typename DType>
void MKLData<DType>::setUsrData(void *ptr)
{
  dataUsr = ptr;
}

template <typename DType>
void *MKLData<DType>::getUsrData()
{
  return dataUsr;
}

template <typename DType>
void *MKLData<DType>::getMklData()
{
  return dataMkl;
}

template <typename DType>
bool MKLData<DType>::isUseNext()
{
  return useNext;
}

template <typename DType>
bool MKLData<DType>::isUsePrev()
{
  return usePrev;
}

template <typename DType>
void MKLData<DType>::setUseNext(bool val)
{
  useNext = val;
}

template <typename DType>
void MKLData<DType>::setUsePrev(bool val)
{
  usePrev = val;
}

template <typename DType>
void MKLData<DType>::cutLastRowColumn(size_t *fromStrides, size_t *toSize,
                                      size_t *toStrides)
{
  // TODO this should be optimized. It's terrible.
  // The funciton of four depth loop cuts off the last column and
  // the last row of every matrix (height * weight) in output generated by
  // MKL2017. memcpy may be much better.
  // Fortunately, it doesn't occur frequently and it will not cost so much.
  //
  // TODO the default dimension is 4
  DType *from = reinterpret_cast<DType *>(dataMkl);
  DType *to   = reinterpret_cast<DType *>(dataUsr);
  PERFSTART();
  for (int n = 0; n < toSize[3]; n++)
    for (int c = 0; c < toSize[2]; c++)
      for (int h = 0; h < toSize[1]; h++)      // height
        for (int w = 0; w < toSize[0]; w++) {  // width
          int toIndex =
              n * toStrides[3] + c * toStrides[2] + h * toStrides[1] + w;
          int fromIndex =
              n * fromStrides[3] + c * fromStrides[2] + h * fromStrides[1] + w;
          *(to + toIndex) = *(from + fromIndex);
        }
  PERFEND("convert : cut last row and column of a matrix");
}

template <typename DType>
void MKLData<DType>::padLastRowColumn(size_t *fromSize, size_t *fromStrides,
                                      size_t *toSize, size_t *toStrides)
{
  DType *from = reinterpret_cast<DType *>(dataUsr);
  DType *to   = reinterpret_cast<DType *>(dataMkl);

  PERFSTART();
  for (int n = 0; n < fromSize[3]; n++) {
    for (int c = 0; c < fromSize[2]; c++) {
      int baseIndex = n * toStrides[3] + c * toStrides[2];

      for (int h = 0; h < fromSize[1]; h++) {  // height
        memcpy(to + baseIndex + h * toStrides[1],
               from + baseIndex + h * fromStrides[1],
               fromSize[0] * sizeof(DType));

        // the last column of a matrix with 0. we only need to set
        // one element to 0, because 0 <= ceil - floor <= 1
        if (toSize[0] != fromSize[0]) {
          int end     = baseIndex + h * toStrides[1] + fromSize[0];
          *(to + end) = 0;
        }
      }

      // pad the last row of a matrix with 0 * width
      if (toSize[1] != fromSize[1]) {
        int end = baseIndex + toSize[1] * toStrides[1];
        memset(to + end, 0, toSize[0] * sizeof(DType));
      }
    }
  }
  PERFEND("convert : pad last row and column of a matrix with 0");
}

template <typename DType>
size_t MKLData<DType>::getMklLayoutSize()
{
  if (layoutMkl)
    return dnnLayoutGetMemorySize<DType>(layoutMkl);
  else
    return 0;
}

template <typename DType>
dnnLayout_t MKLData<DType>::getUsrLayout()
{
  return layoutUsr;
}

template <typename DType>
dnnLayout_t MKLData<DType>::getMklLayout()
{
  if (layoutMkl)
    return layoutMkl;
  else
    return layoutUsr;
}

template <typename JArrayType, typename JType>
class ZipArray
{
 public:
  ZipArray(JNIEnv *env, JArrayType array, jint offset,
           std::shared_ptr<MKLData<JType>> mklData);
  ~ZipArray();

  JType *getPtr();

 private:
  void *ptr;
  JArrayType array;
  JNIEnv *env;
};

template <typename JArrayType, typename JType>
ZipArray<JArrayType, JType>::ZipArray(JNIEnv *env, JArrayType array,
                                      jint offset,
                                      std::shared_ptr<MKLData<JType>> mklData)
{
  this->ptr   = env->GetPrimitiveArrayCritical(array, 0);
  this->env   = env;
  this->array = array;

  JType *usrPtr = reinterpret_cast<JType *>(ptr) + offset;

  if (mklData) mklData->setUsrData(usrPtr);
}

template <typename JArrayType, typename JType>
ZipArray<JArrayType, JType>::~ZipArray()
{
  env->ReleasePrimitiveArrayCritical(array, ptr, 0);
}

template <typename JArrayType, typename JType>
JType *ZipArray<JArrayType, JType>::getPtr()
{
  return reinterpret_cast<JType *>(ptr);
}

#endif
