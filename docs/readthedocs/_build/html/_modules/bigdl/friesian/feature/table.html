<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>bigdl.friesian.feature.table &mdash; BigDL  documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/tabs.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script src="../../../../_static/clipboard.min.js"></script>
        <script src="../../../../_static/copybutton.js"></script>
        <script src="../../../../_static/tabs.js"></script>
        <script src="../../../../_static/design-tabs.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> BigDL
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Quick Start</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Orca/QuickStart/orca-tf-quickstart.html">TensorFlow 1.15 Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Orca/QuickStart/orca-keras-quickstart.html">Keras 2.3 Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Orca/QuickStart/orca-tf2keras-quickstart.html">TensorFlow 2 Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Orca/QuickStart/orca-pytorch-quickstart.html">PyTorch Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Ray/QuickStart/ray-quickstart.html">RayOnSpark Quickstart</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/UserGuide/python.html">Python User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/UserGuide/scala.html">Scala User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/UserGuide/colab.html">Colab User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/UserGuide/docker.html">Docker User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/UserGuide/hadoop.html">Hadoop/YARN User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/UserGuide/k8s.html">K8s User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/UserGuide/databricks.html">Databricks User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/UserGuide/develop.html">Developer Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/UserGuide/known_issues.html">BigDL Known Issues</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Nano</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Nano/Overview/nano.html">Nano User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Nano/Overview/windows_guide.html">Windows User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Nano/QuickStart/pytorch_train.html">BigDL-Nano PyTorch Training Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Nano/QuickStart/pytorch_inference.html">BigDL-Nano PyTorch Inference Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Nano/QuickStart/tensorflow_train.html">BigDL-Nano TensorFlow Training Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Nano/QuickStart/tensorflow_inference.html">BigDL-Nano TensorFlow Inference Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Nano/QuickStart/hpo.html">AutoML Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Nano/Overview/known_issues.html">Nano Known Issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Nano/QuickStart/index.html">Nano Tutorial</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">DLlib</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/DLlib/Overview/dllib.html">DLlib User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/DLlib/Overview/keras-api.html">Keras-Like API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/DLlib/Overview/nnframes.html">Spark ML Pipeline Support</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Orca</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Orca/Overview/orca.html">Orca User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Orca/Overview/orca-context.html">Orca Context</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Orca/Overview/data-parallel-processing.html">Distributed Data Processing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Orca/Overview/distributed-training-inference.html">Distributed Training and Inference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Orca/Overview/distributed-tuning.html">Distributed Hyper-Parameter Tuning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Ray/Overview/ray.html">RayOnSpark</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Orca/Overview/known_issues.html">Orca Known Issues</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Chronos</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Chronos/Overview/chronos.html">Chronos User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Chronos/Overview/deep_dive.html">Chronos Deep Dive</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Chronos/QuickStart/index.html">Chronos Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Chronos/Overview/chronos_known_issue.html">Chronos Known Issue</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">PPML</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/PPML/Overview/ppml.html">Privacy Preserving Machine Learning (PPML) User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/PPML/Overview/trusted_big_data_analytics_and_ml.html">Trusted Big Data Analytics and ML</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/PPML/Overview/trusted_fl.html">Trusted FL (Federated Learning)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/PPML/QuickStart/secure_your_services.html">Secure Your Services</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/PPML/QuickStart/build_kernel_with_sgx.html">Building Linux Kernel from Source with SGX Enabled</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/PPML/QuickStart/deploy_intel_sgx_device_plugin_for_kubernetes.html">Deploy the Intel SGX Device Plugin for Kubernetes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/PPML/QuickStart/trusted-serving-on-k8s-guide.html">Trusted Cluster Serving with Graphene on Kubernetes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/PPML/QuickStart/tpc-h_with_sparksql_on_k8s.html">TPC-H with Trusted SparkSQL on Kubernetes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/PPML/QuickStart/tpc-ds_with_sparksql_on_k8s.html">TPC-DS with Trusted SparkSQL on Kubernetes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/PPML/Overview/azure_ppml.html">Privacy Preserving Machine Learning (PPML) on Azure User Guide</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Serving</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Serving/Overview/serving.html">Cluster Serving User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Serving/QuickStart/serving-quickstart.html">Cluster Serving Quick Start</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Serving/ProgrammingGuide/serving-installation.html">Install Cluster Serving</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Serving/ProgrammingGuide/serving-start.html">Start Cluster Serving</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Serving/ProgrammingGuide/serving-inference.html">Inference by Cluster Serving</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Serving/Example/example.html">Cluster Serving Example</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Serving/FAQ/faq.html">Cluster Serving FAQ</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Serving/FAQ/contribute-guide.html">Contribute to Cluster Serving</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Common Use Case</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Orca/QuickStart/orca-pytorch-distributed-quickstart.html">Use <code class="docutils literal notranslate"><span class="pre">torch.distributed</span></code> in Orca</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/UseCase/spark-dataframe.html">Use Spark Dataframe for Deep Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/UseCase/xshards-pandas.html">Use Distributed Pandas for Deep Learning</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Orca/QuickStart/orca-autoestimator-pytorch-quickstart.html">Enable AutoML for PyTorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Orca/QuickStart/orca-autoxgboost-quickstart.html">Use AutoXGBoost to auto-tune XGBoost parameters</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Python API</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/PythonAPI/Orca/orca.html">Orca API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/PythonAPI/Friesian/feature.html">Friesian Feature API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/PythonAPI/Chronos/index.html">Chronos API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/PythonAPI/Nano/index.html">Nano API</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Real-World Application</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Application/presentations.html">Presentations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Application/blogs.html">Blogs</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../doc/Application/powered-by.html">Powered By</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">BigDL</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      <li>bigdl.friesian.feature.table</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for bigdl.friesian.feature.table</h1><div class="highlight"><pre>
<span></span><span class="c1">#</span>
<span class="c1"># Copyright 2016 The BigDL Authors.</span>
<span class="c1">#</span>
<span class="c1"># Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<span class="c1"># you may not use this file except in compliance with the License.</span>
<span class="c1"># You may obtain a copy of the License at</span>
<span class="c1">#</span>
<span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
<span class="c1">#</span>
<span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
<span class="c1"># distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span class="c1"># See the License for the specific language governing permissions and</span>
<span class="c1"># limitations under the License.</span>
<span class="c1">#</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">hashlib</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">functools</span> <span class="k">import</span> <span class="n">reduce</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pyspark.sql.functions</span> <span class="k">as</span> <span class="nn">F</span>
<span class="kn">from</span> <span class="nn">bigdl.friesian.feature.utils</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">bigdl.dllib.utils.log4Error</span> <span class="k">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">bigdl.orca</span> <span class="k">import</span> <span class="n">OrcaContext</span>
<span class="kn">from</span> <span class="nn">py4j.protocol</span> <span class="k">import</span> <span class="n">Py4JError</span>
<span class="kn">from</span> <span class="nn">pyspark.ml</span> <span class="k">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">pyspark.ml.feature</span> <span class="k">import</span> <span class="n">MinMaxScaler</span><span class="p">,</span> <span class="n">VectorAssembler</span><span class="p">,</span> <span class="n">Bucketizer</span>
<span class="kn">from</span> <span class="nn">pyspark.sql</span> <span class="k">import</span> <span class="n">Row</span><span class="p">,</span> <span class="n">Window</span>
<span class="kn">from</span> <span class="nn">pyspark.sql.column</span> <span class="k">import</span> <span class="n">Column</span>
<span class="kn">from</span> <span class="nn">pyspark.sql.functions</span> <span class="k">import</span> <span class="n">col</span> <span class="k">as</span> <span class="n">pyspark_col</span><span class="p">,</span> <span class="n">concat</span><span class="p">,</span> <span class="n">udf</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">broadcast</span><span class="p">,</span> \
    <span class="n">lit</span><span class="p">,</span> <span class="n">rank</span><span class="p">,</span> <span class="n">monotonically_increasing_id</span><span class="p">,</span> <span class="n">row_number</span><span class="p">,</span> <span class="n">desc</span>
<span class="kn">from</span> <span class="nn">pyspark.sql.types</span> <span class="k">import</span> <span class="n">ArrayType</span><span class="p">,</span> <span class="n">DataType</span><span class="p">,</span> <span class="n">StructType</span><span class="p">,</span> <span class="n">StringType</span><span class="p">,</span> <span class="n">StructField</span>

<span class="n">JAVA_INT_MIN</span> <span class="o">=</span> <span class="o">-</span><span class="mi">2147483648</span>
<span class="n">JAVA_INT_MAX</span> <span class="o">=</span> <span class="mi">2147483647</span>


<div class="viewcode-block" id="Table"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table">[docs]</a><span class="k">class</span> <span class="nc">Table</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">df</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__column_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">schema</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">schema</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_read_parquet</span><span class="p">(</span><span class="n">paths</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">paths</span><span class="p">]</span>
        <span class="n">spark</span> <span class="o">=</span> <span class="n">OrcaContext</span><span class="o">.</span><span class="n">get_spark_session</span><span class="p">()</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">parquet</span><span class="p">(</span><span class="o">*</span><span class="n">paths</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_read_json</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">paths</span><span class="p">]</span>
        <span class="n">spark</span> <span class="o">=</span> <span class="n">OrcaContext</span><span class="o">.</span><span class="n">get_spark_session</span><span class="p">()</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">json</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cols</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">cols</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="s2">&quot;cols should be a column name or list of column names&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_read_csv</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">paths</span><span class="p">]</span>
        <span class="n">spark</span> <span class="o">=</span> <span class="n">OrcaContext</span><span class="o">.</span><span class="n">get_spark_session</span><span class="p">()</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">options</span><span class="p">(</span><span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">inferSchema</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="n">delimiter</span><span class="p">)</span><span class="o">.</span><span class="n">csv</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">if</span> <span class="n">names</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="n">names</span><span class="p">]</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">),</span>
                              <span class="s2">&quot;names should have the same length as the number of columns&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">names</span><span class="p">)):</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">withColumnRenamed</span><span class="p">(</span><span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">tbl</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dtype</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">col</span><span class="p">,</span> <span class="nb">type</span> <span class="ow">in</span> <span class="n">dtype</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="n">tbl</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">tbl</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">columns</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
                <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">),</span>
                                  <span class="s2">&quot;dtype should have the same length as the number of columns&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)):</span>
                    <span class="n">tbl</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="s2">&quot;dtype should be str or a list of str or dict&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tbl</span><span class="o">.</span><span class="n">df</span>

    <span class="k">def</span> <span class="nf">_clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">Table</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<div class="viewcode-block" id="Table.compute"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.compute">[docs]</a>    <span class="k">def</span> <span class="nf">compute</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Trigger computation of the Table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">compute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Table.to_spark_df"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.to_spark_df">[docs]</a>    <span class="k">def</span> <span class="nf">to_spark_df</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the current Table to a Spark DataFrame.</span>

<span class="sd">        :return: The converted Spark DataFrame.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span></div>

<div class="viewcode-block" id="Table.size"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.size">[docs]</a>    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of rows in this Table.</span>

<span class="sd">        :return: The number of rows in the current Table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cnt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">count</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cnt</span></div>

<div class="viewcode-block" id="Table.broadcast"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.broadcast">[docs]</a>    <span class="k">def</span> <span class="nf">broadcast</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Marks the Table as small enough for use in broadcast join.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">broadcast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">)</span></div>

<div class="viewcode-block" id="Table.select"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.select">[docs]</a>    <span class="k">def</span> <span class="nf">select</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">cols</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select specific columns.</span>

<span class="sd">        :param cols: str or a list of str that specifies column names. If it is &#39;*&#39;,</span>
<span class="sd">                     select all the columns.</span>

<span class="sd">        :return: A new Table that contains the specified columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># If cols is None, it makes more sense to throw error</span>
        <span class="c1"># instead of returning an empty Table.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cols</span><span class="p">:</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                              <span class="s2">&quot;cols should be str or a list of str, but got None.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">cols</span><span class="p">))</span></div>

<div class="viewcode-block" id="Table.drop"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.drop">[docs]</a>    <span class="k">def</span> <span class="nf">drop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">cols</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new Table that drops the specified column.</span>
<span class="sd">        This is a no-op if schema doesn&#39;t contain the given column name(s).</span>

<span class="sd">        :param cols: str or a list of str that specifies the name of the columns</span>
<span class="sd">               to drop.</span>

<span class="sd">        :return: A new Table that drops the specified column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="o">*</span><span class="n">cols</span><span class="p">))</span></div>

<div class="viewcode-block" id="Table.limit"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.limit">[docs]</a>    <span class="k">def</span> <span class="nf">limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Limits the result count to the number specified.</span>

<span class="sd">        :param num: int that specifies the number of results.</span>
<span class="sd">        :return: A new Table that contains `num` counts of rows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">limit</span><span class="p">(</span><span class="n">num</span><span class="p">))</span></div>

<div class="viewcode-block" id="Table.repartition"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.repartition">[docs]</a>    <span class="k">def</span> <span class="nf">repartition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_partitions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new Table that has exactly num_partitions partitions.</span>

<span class="sd">        :param num_partitions: target number of partitions</span>
<span class="sd">        :return: a new Table that has num_partitions partitions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">repartition</span><span class="p">(</span><span class="n">num_partitions</span><span class="p">))</span></div>

<div class="viewcode-block" id="Table.get_partition_row_number"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.get_partition_row_number">[docs]</a>    <span class="k">def</span> <span class="nf">get_partition_row_number</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a Table that contains partitionId and corresponding row number.</span>

<span class="sd">        :return: a new Table that contains partitionId and corresponding row number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyspark.sql.functions</span> <span class="k">import</span> <span class="n">spark_partition_id</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&quot;partitionId&quot;</span><span class="p">,</span> <span class="n">spark_partition_id</span><span class="p">())</span>
                           <span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="s2">&quot;partitionId&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">())</span></div>

<div class="viewcode-block" id="Table.fillna"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.fillna">[docs]</a>    <span class="k">def</span> <span class="nf">fillna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace null values.</span>

<span class="sd">        :param value: int, long, float, string, or boolean.</span>
<span class="sd">               Value to replace null values with.</span>
<span class="sd">        :param columns: list of str, the target columns to be filled. If columns=None and value</span>
<span class="sd">               is int, all columns of integer type will be filled. If columns=None and value is</span>
<span class="sd">               long, float, str or boolean, all columns will be filled.</span>

<span class="sd">        :return: A new Table that replaced the null values with the specified value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">check_col_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">JAVA_INT_MIN</span> <span class="o">&lt;=</span> <span class="n">value</span> <span class="o">&lt;=</span> <span class="n">JAVA_INT_MAX</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">columns</span><span class="p">:</span>
                <span class="n">col_not_int_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">columns</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_not_int_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="n">fill_na_int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">columns</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="n">fill_na_int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">columns</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="n">fill_na</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">columns</span><span class="p">))</span></div>

<div class="viewcode-block" id="Table.dropna"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.dropna">[docs]</a>    <span class="k">def</span> <span class="nf">dropna</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s1">&#39;any&#39;</span><span class="p">,</span> <span class="n">thresh</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Drops the rows containing null values in the specified columns.</span>

<span class="sd">        :param columns: str or a list of str that specifies column names. If it is None,</span>
<span class="sd">               it will operate on all columns.</span>
<span class="sd">        :param how: If `how` is &quot;any&quot;, then drop rows containing any null values in `columns`.</span>
<span class="sd">               If `how` is &quot;all&quot;, then drop rows only if every column in `columns` is null for</span>
<span class="sd">               that row.</span>
<span class="sd">        :param thresh: int, if specified, drop rows that have less than thresh non-null values.</span>
<span class="sd">               Default is None.</span>

<span class="sd">        :return: A new Table that drops the rows containing null values in the specified columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dropna</span><span class="p">(</span><span class="n">how</span><span class="p">,</span> <span class="n">thresh</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="n">columns</span><span class="p">))</span></div>

<div class="viewcode-block" id="Table.distinct"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.distinct">[docs]</a>    <span class="k">def</span> <span class="nf">distinct</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select the distinct rows of the Table.</span>

<span class="sd">        :return: A new Table that only contains distinct rows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">distinct</span><span class="p">())</span></div>

<div class="viewcode-block" id="Table.filter"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.filter">[docs]</a>    <span class="k">def</span> <span class="nf">filter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filters the rows that satisfy `condition`. For instance, filter(&quot;col_1 == 1&quot;) will filter</span>
<span class="sd">        the rows that has value 1 at column col_1.</span>

<span class="sd">        :param condition: str that gives the condition for filtering.</span>

<span class="sd">        :return: A new Table with filtered rows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">condition</span><span class="p">))</span></div>

<div class="viewcode-block" id="Table.random_split"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.random_split">[docs]</a>    <span class="k">def</span> <span class="nf">random_split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Randomly split Table into multiple Tables with the provided weights for train, validation</span>
<span class="sd">        and test.</span>

<span class="sd">        :param weights: list of doubles as weights with which to split the Table.</span>
<span class="sd">               Weights will be normalized if they don&#39;t sum up to 1.0.</span>
<span class="sd">        :param seed: The seed for sampling.</span>

<span class="sd">        :return: A list of Tables split by the provided weights.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">randomSplit</span><span class="p">(</span><span class="n">weights</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">df_array</span><span class="p">]</span></div>

    <span class="n">split</span> <span class="o">=</span> <span class="n">random_split</span>

<div class="viewcode-block" id="Table.clip"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.clip">[docs]</a>    <span class="k">def</span> <span class="nf">clip</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clips continuous values so that they are within the range [min, max]. For instance, by</span>
<span class="sd">        setting the min value to 0, all negative values in columns will be replaced with 0.</span>

<span class="sd">        :param columns: str or a list of str, the target columns to be clipped.</span>
<span class="sd">        :param min: numeric, the minimum value to clip values to. Values less than this will be</span>
<span class="sd">               replaced with this value.</span>
<span class="sd">        :param max: numeric, the maximum value to clip values to. Values greater than this will be</span>
<span class="sd">               replaced with this value.</span>

<span class="sd">        :return: A new Table that replaced the value less than `min` with specified `min` and the</span>
<span class="sd">                 value greater than `max` with specified `max`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="nb">max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
                          <span class="s2">&quot;at least one of min and max should be not None&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                              <span class="s2">&quot;columns should be str or a list of str, but got None.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
        <span class="n">check_col_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="n">clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">))</span></div>

<div class="viewcode-block" id="Table.log"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.log">[docs]</a>    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">clipping</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the log of continuous columns.</span>

<span class="sd">        :param columns: str or a list of str, the target columns to calculate log.</span>
<span class="sd">        :param clipping: boolean. Default is True, and in this case the negative values in columns</span>
<span class="sd">               will be clipped to 0 and `log(x+1)` will be calculated. If False, `log(x)` will be</span>
<span class="sd">               calculated.</span>

<span class="sd">        :return: A new Table that replaced value in columns with logged value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                              <span class="s2">&quot;columns should be str or a list of str, but got None.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
        <span class="n">check_col_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="n">log_with_clip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">clipping</span><span class="p">))</span></div>

<div class="viewcode-block" id="Table.fill_median"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.fill_median">[docs]</a>    <span class="k">def</span> <span class="nf">fill_median</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replaces null values with the median in the specified numeric columns. Any column to be</span>
<span class="sd">        filled should not contain only null values.</span>

<span class="sd">        :param columns: str or a list of str that specifies column names. If it is None,</span>
<span class="sd">               it will operate on all numeric columns.</span>

<span class="sd">        :return: A new Table that replaces null values with the median in the specified numeric</span>
<span class="sd">                 columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">check_col_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="n">fill_median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">))</span></div>

<div class="viewcode-block" id="Table.median"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.median">[docs]</a>    <span class="k">def</span> <span class="nf">median</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new Table that has two columns, `column` and `median`, containing the column</span>
<span class="sd">        names and the medians of the specified numeric columns.</span>

<span class="sd">        :param columns: str or a list of str that specifies column names. If it is None,</span>
<span class="sd">               it will operate on all numeric columns.</span>

<span class="sd">        :return: A new Table that contains the medians of the specified columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">check_col_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="n">median</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">))</span></div>

<div class="viewcode-block" id="Table.merge_cols"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.merge_cols">[docs]</a>    <span class="k">def</span> <span class="nf">merge_cols</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">target</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Merge the target column values as a list to a new column.</span>
<span class="sd">        The original columns will be dropped.</span>

<span class="sd">        :param columns: a list of str, the target columns to be merged.</span>
<span class="sd">        :param target: str, the new column name of the merged column.</span>

<span class="sd">        :return: A new Table that replaces columns with a new target column of merged list values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span>
                          <span class="s2">&quot;columns must be a list of column names&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">array</span><span class="p">(</span><span class="n">columns</span><span class="p">))</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="o">*</span><span class="n">columns</span><span class="p">))</span></div>

<div class="viewcode-block" id="Table.rename"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.rename">[docs]</a>    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rename columns with new column names</span>

<span class="sd">        :param columns: dict. Name pairs. For instance, {&#39;old_name1&#39;: &#39;new_name1&#39;, &#39;old_name2&#39;:</span>
<span class="sd">               &#39;new_name2&#39;}&quot;.</span>

<span class="sd">        :return: A new Table with new column names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span>
                          <span class="s2">&quot;columns should be a dictionary of&quot;</span>
                          <span class="s2">&quot; {&#39;old_name1&#39;: &#39;new_name1&#39;, &#39;old_name2&#39;: &#39;new_name2&#39;}&quot;</span><span class="p">)</span>
        <span class="n">new_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>
        <span class="k">for</span> <span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="n">columns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_df</span> <span class="o">=</span> <span class="n">new_df</span><span class="o">.</span><span class="n">withColumnRenamed</span><span class="p">(</span><span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="n">new_df</span><span class="p">)</span></div>

<div class="viewcode-block" id="Table.show"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.show">[docs]</a>    <span class="k">def</span> <span class="nf">show</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">truncate</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prints the first `n` rows to the console.</span>

<span class="sd">        :param n: int, the number of rows to show.</span>
<span class="sd">        :param truncate: If set to True, truncate strings longer than 20 chars by default.</span>
<span class="sd">               If set to a number greater than one, truncates long strings to length `truncate` and</span>
<span class="sd">               align cells right.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">show</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">truncate</span><span class="p">)</span></div>

<div class="viewcode-block" id="Table.get_stats"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.get_stats">[docs]</a>    <span class="k">def</span> <span class="nf">get_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">aggr</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculate the statistics of the values over the target column(s).</span>

<span class="sd">        :param columns: str or a list of str that specifies the name(s) of the target column(s).</span>
<span class="sd">               If columns is None, then the function will return statistics for all numeric columns.</span>
<span class="sd">        :param aggr: str or a list of str or dict to specify aggregate functions,</span>
<span class="sd">               min/max/avg/sum/count are supported.</span>
<span class="sd">               If aggr is a str or a list of str, it contains the name(s) of aggregate function(s).</span>
<span class="sd">               If aggr is a dict, the key is the column name, and the value is the aggregate</span>
<span class="sd">               function(s).</span>

<span class="sd">        :return: dict, the key is the column name, and the value is aggregate result(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">column</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span> <span class="k">if</span> <span class="n">check_column_numeric</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">column</span><span class="p">)]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
        <span class="n">check_col_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
        <span class="n">stats</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aggr</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aggr</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">aggr_strs</span> <span class="o">=</span> <span class="n">aggr</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aggr</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">aggr</span><span class="p">:</span>
                    <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="s2">&quot;aggregate function not defined for the column </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span>
                                      <span class="nb">format</span><span class="p">(</span><span class="n">column</span><span class="p">))</span>
                <span class="n">aggr_strs</span> <span class="o">=</span> <span class="n">aggr</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="s2">&quot;aggr must have type str or a list or dict.&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aggr_strs</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">aggr_strs</span> <span class="o">=</span> <span class="p">[</span><span class="n">aggr_strs</span><span class="p">]</span>
            <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">aggr_str</span> <span class="ow">in</span> <span class="n">aggr_strs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">aggr_str</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="s2">&quot;avg&quot;</span><span class="p">,</span> <span class="s2">&quot;sum&quot;</span><span class="p">,</span> <span class="s2">&quot;count&quot;</span><span class="p">]:</span>
                    <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="s2">&quot;aggregate function must be one of min/max/avg/sum/count,&quot;</span>
                                      <span class="s2">&quot; but got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">aggr_str</span><span class="p">))</span>
                <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">agg</span><span class="p">({</span><span class="n">column</span><span class="p">:</span> <span class="n">aggr_str</span><span class="p">})</span><span class="o">.</span><span class="n">collect</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">stats</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="k">else</span> <span class="n">values</span>
        <span class="k">return</span> <span class="n">stats</span></div>

<div class="viewcode-block" id="Table.min"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new Table that has two columns, `column` and `min`, containing the column</span>
<span class="sd">        names and the minimum values of the specified numeric columns.</span>

<span class="sd">        :param columns: str or a list of str that specifies column names. If it is None,</span>
<span class="sd">               it will operate on all numeric columns.</span>

<span class="sd">        :return: A new Table that contains the minimum values of the specified columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stats</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[(</span><span class="n">column</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">column</span><span class="p">]))</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="n">StructType</span><span class="p">([</span><span class="n">StructField</span><span class="p">(</span><span class="s2">&quot;column&quot;</span><span class="p">,</span> <span class="n">StringType</span><span class="p">(),</span> <span class="kc">True</span><span class="p">),</span>
                             <span class="n">StructField</span><span class="p">(</span><span class="s2">&quot;min&quot;</span><span class="p">,</span> <span class="n">FloatType</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)])</span>
        <span class="n">spark</span> <span class="o">=</span> <span class="n">OrcaContext</span><span class="o">.</span><span class="n">get_spark_session</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="n">spark</span><span class="o">.</span><span class="n">createDataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">schema</span><span class="p">))</span></div>

<div class="viewcode-block" id="Table.max"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a new Table that has two columns, `column` and `max`, containing the column</span>
<span class="sd">        names and the maximum values of the specified numeric columns.</span>

<span class="sd">        :param columns: str or a list of str that specifies column names. If it is None,</span>
<span class="sd">               it will operate on all numeric columns.</span>

<span class="sd">        :return: A new Table that contains the maximum values of the specified columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stats</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">[(</span><span class="n">column</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">column</span><span class="p">]))</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">data</span><span class="p">]</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="n">StructType</span><span class="p">([</span><span class="n">StructField</span><span class="p">(</span><span class="s2">&quot;column&quot;</span><span class="p">,</span> <span class="n">StringType</span><span class="p">(),</span> <span class="kc">True</span><span class="p">),</span>
                             <span class="n">StructField</span><span class="p">(</span><span class="s2">&quot;max&quot;</span><span class="p">,</span> <span class="n">FloatType</span><span class="p">(),</span> <span class="kc">True</span><span class="p">)])</span>
        <span class="n">spark</span> <span class="o">=</span> <span class="n">OrcaContext</span><span class="o">.</span><span class="n">get_spark_session</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="n">spark</span><span class="o">.</span><span class="n">createDataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">schema</span><span class="p">))</span></div>

<div class="viewcode-block" id="Table.to_list"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.to_list">[docs]</a>    <span class="k">def</span> <span class="nf">to_list</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert all values of the target column to a list.</span>
<span class="sd">        Only call this if the Table is small enough.</span>

<span class="sd">        :param column: str, specifies the name of target column.</span>

<span class="sd">        :return: list, contains all values of the target column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                              <span class="s2">&quot;Column must have type str.&quot;</span><span class="p">)</span>
        <span class="n">check_col_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="p">[</span><span class="n">column</span><span class="p">])</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">column</span><span class="p">)</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">flatMap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>

<div class="viewcode-block" id="Table.to_dict"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.to_dict">[docs]</a>    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the Table to a dictionary.</span>
<span class="sd">        Only call this if the Table is small enough.</span>

<span class="sd">        :return: dict, the key is the column name, and the value is the list containing</span>
<span class="sd">        all values in the corresponding column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">row</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">collect</span><span class="p">()]</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">column</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">columns</span><span class="p">):</span>
            <span class="n">result</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">result</span></div>

<div class="viewcode-block" id="Table.add"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Increase all of values of the target numeric column(s) by a constant value.</span>

<span class="sd">        :param columns: str or a list of str, the target columns to be increased.</span>
<span class="sd">        :param value: numeric (int/float/double/short/long), the constant value to be added.</span>

<span class="sd">        :return: A new Table with updated numeric values on specified columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                              <span class="s2">&quot;Columns should be str or a list of str, but got None&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
        <span class="n">check_col_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
        <span class="n">new_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">new_df</span><span class="o">.</span><span class="n">schema</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">dataType</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">IntegerType</span><span class="p">(),</span> <span class="n">ShortType</span><span class="p">(),</span>
                                                      <span class="n">LongType</span><span class="p">(),</span> <span class="n">FloatType</span><span class="p">(),</span>
                                                      <span class="n">DecimalType</span><span class="p">(),</span> <span class="n">DoubleType</span><span class="p">()]:</span>
                <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="s2">&quot;Column type should be numeric, but have type </span><span class="si">{}</span><span class="s2"> &quot;</span>
                                  <span class="s2">&quot;for column </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">new_df</span><span class="o">.</span><span class="n">schema</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">dataType</span><span class="p">,</span> <span class="n">column</span><span class="p">))</span>
            <span class="n">new_df</span> <span class="o">=</span> <span class="n">new_df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">pyspark_col</span><span class="p">(</span><span class="n">column</span><span class="p">)</span> <span class="o">+</span> <span class="n">lit</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="n">new_df</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">columns</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get column names of the Table.</span>

<span class="sd">        :return: A list of strings that specify column names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__column_names</span>

<div class="viewcode-block" id="Table.sample"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.sample">[docs]</a>    <span class="k">def</span> <span class="nf">sample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fraction</span><span class="p">,</span> <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a sampled subset of Table.</span>

<span class="sd">        :param fraction: float, fraction of rows to generate, should be within the</span>
<span class="sd">               range [0, 1].</span>
<span class="sd">        :param replace: allow or disallow sampling of the same row more than once.</span>
<span class="sd">        :param seed: seed for sampling.</span>

<span class="sd">        :return: A new Table with sampled rows.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">sample</span><span class="p">(</span><span class="n">withReplacement</span><span class="o">=</span><span class="n">replace</span><span class="p">,</span> <span class="n">fraction</span><span class="o">=</span><span class="n">fraction</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">seed</span><span class="p">))</span></div>

<div class="viewcode-block" id="Table.ordinal_shuffle_partition"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.ordinal_shuffle_partition">[docs]</a>    <span class="k">def</span> <span class="nf">ordinal_shuffle_partition</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shuffle each partition of the Table by adding a random ordinal column for each row and sort</span>
<span class="sd">        by this ordinal column within each partition.</span>

<span class="sd">        :return: A new Table with shuffled partitions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="n">ordinal_shuffle_partition</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">))</span></div>

<div class="viewcode-block" id="Table.write_parquet"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.write_parquet">[docs]</a>    <span class="k">def</span> <span class="nf">write_parquet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;overwrite&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the Table to Parquet file.</span>

<span class="sd">        :param path: str, the path to the Parquet file.</span>
<span class="sd">        :param mode: str. One of &quot;append&quot;, &quot;overwrite&quot;, &quot;error&quot; or &quot;ignore&quot;.</span>
<span class="sd">               append: Append contents to the existing data.</span>
<span class="sd">               overwrite: Overwrite the existing data.</span>
<span class="sd">               error: Throw an exception if the data already exists.</span>
<span class="sd">               ignore: Silently ignore this operation if data already exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">write_parquet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span></div>

<div class="viewcode-block" id="Table.cast"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.cast">[docs]</a>    <span class="k">def</span> <span class="nf">cast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cast columns to the specified type.</span>

<span class="sd">        :param columns: str or a list of str that specifies column names.</span>
<span class="sd">               If it is None, then cast all of the columns.</span>
<span class="sd">        :param dtype: str (&quot;string&quot;, &quot;boolean&quot;, &quot;int&quot;, &quot;long&quot;, &quot;short&quot;, &quot;float&quot;, &quot;double&quot;)</span>
<span class="sd">               that specifies the data type.</span>

<span class="sd">        :return: A new Table that casts all of the specified columns to the specified type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
            <span class="n">check_col_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
        <span class="n">valid_types</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;str&quot;</span><span class="p">,</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="s2">&quot;boolean&quot;</span><span class="p">,</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span>
                       <span class="s2">&quot;integer&quot;</span><span class="p">,</span> <span class="s2">&quot;long&quot;</span><span class="p">,</span> <span class="s2">&quot;short&quot;</span><span class="p">,</span> <span class="s2">&quot;float&quot;</span><span class="p">,</span> <span class="s2">&quot;double&quot;</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">dtype</span> <span class="ow">in</span> <span class="n">valid_types</span><span class="p">))</span> \
                <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">DataType</span><span class="p">):</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                              <span class="s2">&quot;dtype should be string, boolean, int, long, short, float, double.&quot;</span><span class="p">)</span>
        <span class="n">transform_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;str&quot;</span><span class="p">:</span> <span class="s2">&quot;string&quot;</span><span class="p">,</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span> <span class="s2">&quot;boolean&quot;</span><span class="p">,</span> <span class="s2">&quot;integer&quot;</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">}</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">transform_dict</span><span class="p">[</span><span class="n">dtype</span><span class="p">]</span> <span class="k">if</span> <span class="n">dtype</span> <span class="ow">in</span> <span class="n">transform_dict</span> <span class="k">else</span> <span class="n">dtype</span>
        <span class="n">df_cast</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">df_cast</span><span class="o">.</span><span class="n">df</span> <span class="o">=</span> <span class="n">df_cast</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pyspark_col</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">dtype</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">df_cast</span></div>

<div class="viewcode-block" id="Table.write_csv"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.write_csv">[docs]</a>    <span class="k">def</span> <span class="nf">write_csv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;overwrite&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">num_partitions</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the Table to csv file.</span>

<span class="sd">        :param path: str, the path to the csv file.</span>
<span class="sd">        :param delimiter: str, the delimiter to use for separating fields. Default is &quot;,&quot;.</span>
<span class="sd">        :param mode: str. One of &quot;append&quot;, &quot;overwrite&quot;, &quot;error&quot; or &quot;ignore&quot;.</span>
<span class="sd">               append: Append the contents of this StringIndex to the existing data.</span>
<span class="sd">               overwrite: Overwrite the existing data.</span>
<span class="sd">               error: Throw an exception if the data already exists.</span>
<span class="sd">               ignore: Silently ignore this operation if the data already exists.</span>
<span class="sd">        :param header: boolean, whether to include the schema at the first line of the csv file.</span>
<span class="sd">               Default is True.</span>
<span class="sd">        :param num_partitions: positive int. The number of files to write.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">num_partitions</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">repartition</span><span class="p">(</span><span class="n">num_partitions</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">csv</span><span class="p">(</span>
                <span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">delimiter</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">write</span><span class="o">.</span><span class="n">csv</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">header</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">delimiter</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_concat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="s2">&quot;outer&quot;</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">concat_inner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df2</span><span class="p">):</span>
            <span class="n">col_names_1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="n">col_names_2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df2</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">col_names_1</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">col_names_2</span><span class="p">)):</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">col_names_2</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">col_names_1</span><span class="p">)):</span>
                <span class="n">df2</span> <span class="o">=</span> <span class="n">df2</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unionByName</span><span class="p">(</span><span class="n">df2</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">concat_outer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df2</span><span class="p">):</span>
            <span class="n">col_names_1</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="n">col_names_2</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">df2</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">col_names_1</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">col_names_2</span><span class="p">):</span>
                <span class="n">df2</span> <span class="o">=</span> <span class="n">df2</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">lit</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">schema</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">dataType</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">col_names_2</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">col_names_1</span><span class="p">):</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">lit</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">df2</span><span class="o">.</span><span class="n">schema</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">dataType</span><span class="p">))</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">unionByName</span><span class="p">(</span><span class="n">df2</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">join</span> <span class="o">==</span> <span class="s2">&quot;outer&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">concat_outer</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">concat_inner</span>

<div class="viewcode-block" id="Table.concat"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.concat">[docs]</a>    <span class="k">def</span> <span class="nf">concat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tables</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;inner&quot;</span><span class="p">,</span> <span class="n">distinct</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Concatenate a list of Tables into one Table in the dimension of row.</span>

<span class="sd">        :param tables: a Table or a list of Tables.</span>
<span class="sd">        :param mode: str, either inner or outer. For inner mode, the new Table would only</span>
<span class="sd">               contain columns that are shared by all Tables. For outer mode, the resulting</span>
<span class="sd">               Table would contain all the columns that appear in all Tables.</span>
<span class="sd">        :param distinct: boolean. If True, the result Table would only contain distinct rows.</span>
<span class="sd">               Default is False.</span>

<span class="sd">        :return: A single concatenated Table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mode</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;outer&quot;</span><span class="p">,</span> <span class="s2">&quot;inner&quot;</span><span class="p">]:</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                              <span class="s2">&quot;concat mode should be either outer or inner,&quot;</span>
                              <span class="s2">&quot;but got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tables</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">tables</span> <span class="o">=</span> <span class="p">[</span><span class="n">tables</span><span class="p">]</span>
        <span class="n">dfs</span> <span class="o">=</span> <span class="p">[</span><span class="n">table</span><span class="o">.</span><span class="n">df</span> <span class="k">for</span> <span class="n">table</span> <span class="ow">in</span> <span class="n">tables</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_concat</span><span class="p">(</span><span class="n">mode</span><span class="p">),</span> <span class="n">dfs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">distinct</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">distinct</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div>

<div class="viewcode-block" id="Table.drop_duplicates"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.drop_duplicates">[docs]</a>    <span class="k">def</span> <span class="nf">drop_duplicates</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep</span><span class="o">=</span><span class="s2">&quot;min&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new Table with duplicate rows removed.</span>

<span class="sd">        :param subset: str or a list of str, specifies which column(s) to be considered when</span>
<span class="sd">               referring to duplication. If subset is None, all the columns will be considered.</span>
<span class="sd">        :param sort_cols: str or a list of str, specifies the column(s) to determine which</span>
<span class="sd">               item to keep when duplicated. If sort_cols is None, duplicate rows will be</span>
<span class="sd">               dropped randomly.</span>
<span class="sd">        :param keep: str, the strategy to keep the duplicate, either min and max. Default is min.</span>
<span class="sd">               It will only take effect when sort_cols is not None.</span>
<span class="sd">               If keep is min, rows with the smallest values in sort_cols will be kept.</span>
<span class="sd">               If keep is max, rows with the largest values in sort_cols will be kept.</span>

<span class="sd">        :return: A new Table with duplicate rows removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">subset</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">subset</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">subset</span> <span class="o">=</span> <span class="p">[</span><span class="n">subset</span><span class="p">]</span>
            <span class="n">check_col_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">subset</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">subset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">if</span> <span class="n">sort_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dropDuplicates</span><span class="p">(</span><span class="n">subset</span><span class="o">=</span><span class="n">subset</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sort_cols</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">sort_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">sort_cols</span><span class="p">]</span>
        <span class="n">check_col_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">sort_cols</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">keep</span> <span class="o">==</span> <span class="s2">&quot;min&quot;</span><span class="p">:</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">Window</span><span class="o">.</span><span class="n">partitionBy</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span><span class="o">.</span><span class="n">orderBy</span><span class="p">(</span><span class="o">*</span><span class="n">sort_cols</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">keep</span> <span class="o">==</span> <span class="s2">&quot;max&quot;</span><span class="p">:</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">Window</span><span class="o">.</span><span class="n">partitionBy</span><span class="p">(</span><span class="n">subset</span><span class="p">)</span><span class="o">.</span><span class="n">orderBy</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">[</span><span class="n">sort_col</span><span class="p">]</span><span class="o">.</span><span class="n">desc</span><span class="p">()</span>
                                                          <span class="k">for</span> <span class="n">sort_col</span> <span class="ow">in</span> <span class="n">sort_cols</span><span class="p">],</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                              <span class="s2">&quot;keep should be either min or max, but got </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">keep</span><span class="p">))</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s1">&#39;id&#39;</span><span class="p">,</span> <span class="n">monotonically_increasing_id</span><span class="p">())</span> \
            <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s1">&#39;rank&#39;</span><span class="p">,</span> <span class="n">rank</span><span class="p">()</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">window</span><span class="p">))</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pyspark_col</span><span class="p">(</span><span class="s1">&#39;rank&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;rank&#39;</span><span class="p">,</span> <span class="s1">&#39;id&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div>

<div class="viewcode-block" id="Table.append_column"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.append_column">[docs]</a>    <span class="k">def</span> <span class="nf">append_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append a column with a constant value to the Table.</span>

<span class="sd">        :param name: str, the name of the new column.</span>
<span class="sd">        :param column: pyspark.sql.column.Column, new column to be added into the table.</span>

<span class="sd">        :return: A new Table with the appended column.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">Column</span><span class="p">),</span>
                          <span class="s2">&quot;column should be a pyspark.sql.column.Column&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">column</span><span class="p">))</span></div>

<div class="viewcode-block" id="Table.subtract"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.subtract">[docs]</a>    <span class="k">def</span> <span class="nf">subtract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new :class:`Table` containing rows in this :class:`Table`</span>
<span class="sd">        but not in another :class:`Table`</span>

<span class="sd">        :param other: Table.</span>
<span class="sd">        :return: A new Table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">df</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the target column of the Table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="fm">__getattr__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

<div class="viewcode-block" id="Table.col"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.col">[docs]</a>    <span class="k">def</span> <span class="nf">col</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the target column of the Table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">pyspark_col</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="Table.sort"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.sort">[docs]</a>    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">cols</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort the Table by specified column(s).</span>

<span class="sd">        :param cols: list of :class:`Column` or column names to sort by.</span>
<span class="sd">        :param ascending: boolean or list of boolean (default ``True``).</span>
<span class="sd">               Sort ascending vs. descending. Specify list for multiple sort orders.</span>
<span class="sd">               If a list is specified, length of the list must equal length of the `cols`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">cols</span><span class="p">:</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                              <span class="s2">&quot;cols should be str or a list of str, but got None.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">*</span><span class="n">cols</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span></div>

    <span class="n">order_by</span> <span class="o">=</span> <span class="n">sort</span>

<div class="viewcode-block" id="Table.to_pandas"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.to_pandas">[docs]</a>    <span class="k">def</span> <span class="nf">to_pandas</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">toPandas</span><span class="p">()</span></div>

<div class="viewcode-block" id="Table.cache"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.cache">[docs]</a>    <span class="k">def</span> <span class="nf">cache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Persist this Table in memory.</span>

<span class="sd">        :return: This Table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">cache</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Table.uncache"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.uncache">[docs]</a>    <span class="k">def</span> <span class="nf">uncache</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Make this table as non-persistent and remove all its blocks from memory.</span>

<span class="sd">        :return: This Table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">is_cached</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">unpersist</span><span class="p">()</span>
            <span class="k">except</span> <span class="n">Py4JError</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Try to unpersist an uncached table&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="Table.coalesce"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.coalesce">[docs]</a>    <span class="k">def</span> <span class="nf">coalesce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_partitions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new Table that has exactly num_partitions partitions.</span>
<span class="sd">        coalesce uses existing partitions to minimize the amount of data that&#39;s shuffled.</span>

<span class="sd">        :param num_partitions: target number of partitions</span>
<span class="sd">        :return: a new Table that has num_partitions partitions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">coalesce</span><span class="p">(</span><span class="n">num_partitions</span><span class="p">))</span></div>

<div class="viewcode-block" id="Table.intersect"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.intersect">[docs]</a>    <span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new :class:`Table` containing rows only in both this :class:`Table`</span>
<span class="sd">        and another :class:`Table`</span>

<span class="sd">        :param other: Table.</span>
<span class="sd">        :return: A new Table.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">df</span><span class="p">))</span></div>

<div class="viewcode-block" id="Table.collect"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.Table.collect">[docs]</a>    <span class="k">def</span> <span class="nf">collect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns all the records as a list of :class:`Row`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtypes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns all column names and their data types as a list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">()</span></div>


<div class="viewcode-block" id="FeatureTable"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable">[docs]</a><span class="k">class</span> <span class="nc">FeatureTable</span><span class="p">(</span><span class="n">Table</span><span class="p">):</span>
<div class="viewcode-block" id="FeatureTable.read_parquet"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.read_parquet">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_parquet</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">paths</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads Parquet files as a FeatureTable.</span>

<span class="sd">        :param paths: str or a list of str, the path(s) to Parquet file(s).</span>

<span class="sd">        :return: A FeatureTable for recommendation data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">Table</span><span class="o">.</span><span class="n">_read_parquet</span><span class="p">(</span><span class="n">paths</span><span class="p">))</span></div>

<div class="viewcode-block" id="FeatureTable.read_json"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.read_json">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_json</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads json files as a FeatureTable.</span>

<span class="sd">        :param paths: str or a list of str, the path(s) to the json file(s).</span>
<span class="sd">        :param cols: str or a list of str. The columns to select from the json file(s).</span>
<span class="sd">               Default is None and in this case all the columns will be considered.</span>

<span class="sd">        :return: A FeatureTable for recommendation data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">Table</span><span class="o">.</span><span class="n">_read_json</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">cols</span><span class="p">))</span></div>

<div class="viewcode-block" id="FeatureTable.read_csv"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.read_csv">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_csv</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s2">&quot;,&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads csv files as a FeatureTable.</span>

<span class="sd">        :param paths: str or a list of str, the path(s) to the csv file(s).</span>
<span class="sd">        :param delimiter: str, the delimiter to use for parsing the csv file(s). Default is &quot;,&quot;.</span>
<span class="sd">        :param header: boolean, whether the first line of the csv file(s) will be treated</span>
<span class="sd">               as the header for column names. Default is False.</span>
<span class="sd">        :param names: str or a list of str, the column names for the csv file(s). You need to</span>
<span class="sd">               provide this if the header cannot be inferred. If specified, names should</span>
<span class="sd">               have the same length as the number of columns.</span>
<span class="sd">        :param dtype: str or a list of str or dict, the column data type(s) for the csv file(s).\</span>
<span class="sd">               You may need to provide this if you want to change the default inferred types</span>
<span class="sd">               of specified columns.</span>
<span class="sd">               If dtype is a str, then all the columns will be cast to the target dtype.</span>
<span class="sd">               If dtype is a list of str, then it should have the same length as the number of</span>
<span class="sd">               columns and each column will be cast to the corresponding str dtype.</span>
<span class="sd">               If dtype is a dict, then the key should be the column name and the value should be</span>
<span class="sd">               the str dtype to cast the column to.</span>

<span class="sd">        :return: A FeatureTable for recommendation data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">Table</span><span class="o">.</span><span class="n">_read_csv</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">delimiter</span><span class="p">,</span> <span class="n">header</span><span class="p">,</span> <span class="n">names</span><span class="p">,</span> <span class="n">dtype</span><span class="p">))</span></div>

<div class="viewcode-block" id="FeatureTable.read_text"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.read_text">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_text</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">col_name</span><span class="o">=</span><span class="s2">&quot;value&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads text files as a FeatureTable.</span>

<span class="sd">        :param paths: str or a list of str, the path(s) to the text file(s).</span>
<span class="sd">        :param col_name: the column name of the text. Default is &quot;value&quot;.</span>

<span class="sd">        :return: A FeatureTable for recommendation data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spark</span> <span class="o">=</span> <span class="n">OrcaContext</span><span class="o">.</span><span class="n">get_spark_session</span><span class="p">()</span>
        <span class="n">tbl</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">spark</span><span class="o">.</span><span class="n">read</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">paths</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">col_name</span> <span class="o">!=</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span>
            <span class="n">tbl</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">.</span><span class="n">rename</span><span class="p">({</span><span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="n">col_name</span><span class="p">})</span>
        <span class="k">return</span> <span class="n">tbl</span></div>

<div class="viewcode-block" id="FeatureTable.from_pandas"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.from_pandas">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_pandas</span><span class="p">(</span><span class="n">pandas_df</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the contents of of a pandas DataFrame as FeatureTable.</span>

<span class="sd">        :param pandas_df: a pandas DataFrame.</span>

<span class="sd">        :return: A FeatureTable for recommendation data.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spark</span> <span class="o">=</span> <span class="n">OrcaContext</span><span class="o">.</span><span class="n">get_spark_session</span><span class="p">()</span>
        <span class="n">sparkDF</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">createDataFrame</span><span class="p">(</span><span class="n">pandas_df</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">sparkDF</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatureTable.encode_string"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.encode_string">[docs]</a>    <span class="k">def</span> <span class="nf">encode_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">broadcast</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">do_split</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                      <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">sort_for_array</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_most_frequent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Encode columns with provided list of StringIndex. Unknown string will be</span>
<span class="sd">        None after the encoding and you may need to fillna with 0.</span>

<span class="sd">        :param columns: str or a list of str, the target columns to be encoded.</span>
<span class="sd">        :param indices: StringIndex or a list of StringIndex, StringIndexes of target columns.</span>
<span class="sd">               The StringIndex should at least have two columns: id and the corresponding</span>
<span class="sd">               categorical column.</span>
<span class="sd">               Or it can be a dict or a list of dicts. In this case,</span>
<span class="sd">               the keys of the dict should be within the categorical column</span>
<span class="sd">               and the values are the target ids to be encoded.</span>
<span class="sd">        :param broadcast: bool, whether need to broadcast index when encode string.</span>
<span class="sd">               Default is True.</span>
<span class="sd">        :param do_split: bool, whether need to split column value to array to encode string.</span>
<span class="sd">               Default is False.</span>
<span class="sd">        :param sep: str, a string representing a regular expression to split a column value.</span>
<span class="sd">               Default is &#39;,&#39;.</span>
<span class="sd">        :param sort_for_array: bool, whether need to sort array columns. Default is False.</span>
<span class="sd">        :param keep_most_frequent: bool, whether need to keep most frequent value as the</span>
<span class="sd">               column value. Default is False.</span>

<span class="sd">        :return: A new FeatureTable which transforms categorical features into unique integer</span>
<span class="sd">                 values with provided StringIndexes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">indices</span><span class="p">]</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">),</span>
                          <span class="s2">&quot;columns len doesn&#39;t match indices lenngth&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">StringIndex</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">columns</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),</span>
                               <span class="nb">enumerate</span><span class="p">(</span><span class="n">indices</span><span class="p">)))</span>
        <span class="n">data_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)):</span>
            <span class="n">index_tbl</span> <span class="o">=</span> <span class="n">indices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">col_name</span> <span class="o">=</span> <span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">broadcast</span><span class="p">:</span>
                <span class="n">index_tbl</span><span class="o">.</span><span class="n">broadcast</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">do_split</span><span class="p">:</span>
                <span class="n">data_df</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">index_tbl</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span> \
                    <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span><span class="o">.</span><span class="n">withColumnRenamed</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">col_name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data_df</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s1">&#39;row_id&#39;</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">monotonically_increasing_id</span><span class="p">())</span>
                <span class="n">tmp_df</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;row_id&#39;</span><span class="p">,</span> <span class="n">col_name</span><span class="p">)</span> \
                    <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">col_name</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">explode</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">col_name</span><span class="p">),</span> <span class="n">sep</span><span class="p">)))</span>
                <span class="n">tmp_df</span> <span class="o">=</span> <span class="n">tmp_df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">index_tbl</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">col_name</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span> \
                    <span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">isNotNull</span><span class="p">())</span>
                <span class="n">tmp_df</span> <span class="o">=</span> <span class="n">tmp_df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="s1">&#39;row_id&#39;</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">keep_most_frequent</span><span class="p">:</span>
                    <span class="n">tmp_df</span> <span class="o">=</span> <span class="n">tmp_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;row_id&#39;</span><span class="p">)</span> \
                        <span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">array_sort</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">collect_list</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">)))</span>
                             <span class="o">.</span><span class="n">getItem</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">sort_for_array</span><span class="p">:</span>
                    <span class="n">tmp_df</span> <span class="o">=</span> <span class="n">tmp_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;row_id&#39;</span><span class="p">)</span> \
                        <span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">array_sort</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">collect_list</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">)))</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">tmp_df</span> <span class="o">=</span> <span class="n">tmp_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="s1">&#39;row_id&#39;</span><span class="p">)</span> \
                        <span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">collect_list</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">))</span>
                <span class="n">data_df</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tmp_df</span><span class="p">,</span> <span class="s1">&#39;row_id&#39;</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">)</span> \
                    <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s1">&#39;row_id&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span><span class="o">.</span><span class="n">withColumnRenamed</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">col_name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">data_df</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatureTable.filter_by_frequency"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.filter_by_frequency">[docs]</a>    <span class="k">def</span> <span class="nf">filter_by_frequency</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">min_freq</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Filter the FeatureTable by the given minimum frequency on the target columns.</span>

<span class="sd">        :param columns: str or a list of str, column names which are considered for filtering.</span>
<span class="sd">        :param min_freq: int, min frequency. Columns with occurrence below this value</span>
<span class="sd">               would be filtered.</span>

<span class="sd">        :return: A new FeatureTable with filtered records.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">freq_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
        <span class="n">name_string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">name_string</span> <span class="o">=</span> <span class="n">name_string</span> <span class="o">+</span> <span class="n">column</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span>
        <span class="n">filter_col_name</span> <span class="o">=</span> <span class="n">name_string</span> <span class="o">+</span> <span class="s1">&#39;count&#39;</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">freq_df</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">count</span><span class="p">()</span><span class="o">.</span><span class="n">withColumnRenamed</span><span class="p">(</span><span class="s1">&#39;count&#39;</span><span class="p">,</span> <span class="n">filter_col_name</span><span class="p">)</span>
        <span class="n">group</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">filter_col_name</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">min_freq</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">filter_col_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">group</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatureTable.hash_encode"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.hash_encode">[docs]</a>    <span class="k">def</span> <span class="nf">hash_encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;md5&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Hash encode for categorical column(s).</span>

<span class="sd">        :param columns: str or a list of str, the target columns to be encoded.</span>
<span class="sd">               For dense features, you need to cut them into discrete intervals beforehand.</span>
<span class="sd">        :param bins: int, defines the number of equal-width bins in the range of column(s) values.</span>
<span class="sd">        :param method: hashlib supported method, like md5, sha256 etc.</span>

<span class="sd">        :return: A new FeatureTable with hash encoded columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">hash_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)):</span>
            <span class="n">col_name</span> <span class="o">=</span> <span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">hash_str</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">hashlib</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">encode</span><span class="p">(</span><span class="s1">&#39;utf_8&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">hexdigest</span><span class="p">()</span>
            <span class="n">hash_int</span> <span class="o">=</span> <span class="n">udf</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">hash_str</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="mi">16</span><span class="p">)</span> <span class="o">%</span> <span class="n">bins</span><span class="p">,</span> <span class="n">returnType</span><span class="o">=</span><span class="n">IntegerType</span><span class="p">())</span>
            <span class="n">hash_df</span> <span class="o">=</span> <span class="n">hash_df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">col_name</span><span class="p">,</span> <span class="n">hash_int</span><span class="p">(</span><span class="n">pyspark_col</span><span class="p">(</span><span class="n">col_name</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">hash_df</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatureTable.cross_hash_encode"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.cross_hash_encode">[docs]</a>    <span class="k">def</span> <span class="nf">cross_hash_encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cross_columns</span><span class="p">,</span> <span class="n">bin_sizes</span><span class="p">,</span> <span class="n">cross_col_names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;md5&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cross columns and hashed to specified bin size.</span>

<span class="sd">        :param cross_columns: nested list of str, nested list of categorical column names to be</span>
<span class="sd">               encoded as cross features. e.g. [[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]].</span>
<span class="sd">               For dense features, you need to cut them into discrete intervals beforehand.</span>
<span class="sd">        :param bin_sizes: list of int, defined the numbers of equal-width bins in the range</span>
<span class="sd">               of columns values. e.g. [100, 200].</span>
<span class="sd">        :param cross_col_names: list of str, the column names for output cross columns.</span>
<span class="sd">               Default is None, and in this case the default cross column name will</span>
<span class="sd">               be &#39;col1_col2&#39; for [&#39;col1&#39;, &#39;col2&#39;]. e.g. [&#39;cross_1&#39;, &#39;cross_2&#39;].</span>
<span class="sd">        :param method: hashlib supported method, like md5, sha256 etc.</span>

<span class="sd">        :return: A new FeatureTable with the target cross columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For compatibility with previous versions</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cross_columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cross_columns</span><span class="p">):</span>
            <span class="n">cross_columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">cross_columns</span><span class="p">]</span>
            <span class="n">bin_sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">bin_sizes</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cross_col_names</span><span class="p">:</span>
                <span class="n">cross_col_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">cross_col_names</span><span class="p">]</span>

        <span class="c1"># check input params</span>
        <span class="n">invalidInputError</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">cross_columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">cross_columns</span><span class="p">),</span>
            <span class="s2">&quot;cross_columns should be a nested list of string&quot;</span><span class="p">)</span>
        <span class="n">invalidInputError</span><span class="p">(</span>
            <span class="nb">isinstance</span><span class="p">(</span><span class="n">bin_sizes</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">bin_sizes</span><span class="p">),</span>
            <span class="s2">&quot;bin_sizes should be a list of int&quot;</span><span class="p">)</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cross_columns</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">bin_sizes</span><span class="p">),</span>
                          <span class="s2">&quot;cross_columns and bin_sizes should have the same length&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cross_col_names</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">cross_col_names</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span>
                              <span class="s2">&quot;cross_col_names should be None or a list of string&quot;</span><span class="p">)</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bin_sizes</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cross_col_names</span><span class="p">),</span>
                              <span class="s2">&quot;cross_columns, bin_sizes and cross_col_names should have the same &quot;</span>
                              <span class="s2">&quot;length&quot;</span><span class="p">)</span>

        <span class="n">cross_hash_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cross_columns</span><span class="p">)):</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cross_columns</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span>
                              <span class="s2">&quot;each element in cross_columns should have &gt;= 2 columns&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cross_col_names</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">cross_col_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cross_col_name</span> <span class="o">=</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">cross_columns</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">cross_col_names</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="nb">str</span><span class="p">),</span>
                                  <span class="s2">&quot;each element in cross_col_names should be None or string&quot;</span><span class="p">)</span>
                <span class="n">cross_col_name</span> <span class="o">=</span> <span class="n">cross_col_names</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">cross_hash_df</span> <span class="o">=</span> <span class="n">cross_hash_df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                <span class="n">cross_col_name</span><span class="p">,</span> <span class="n">concat</span><span class="p">(</span><span class="o">*</span><span class="n">cross_columns</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>

            <span class="n">cross_hash_df</span> <span class="o">=</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">cross_hash_df</span><span class="p">)</span><span class="o">.</span><span class="n">hash_encode</span><span class="p">(</span>
                <span class="n">cross_col_name</span><span class="p">,</span> <span class="n">bin_sizes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">method</span><span class="p">)</span><span class="o">.</span><span class="n">df</span>
        <span class="k">return</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">cross_hash_df</span><span class="p">)</span></div>

    <span class="n">cross_columns</span> <span class="o">=</span> <span class="n">cross_hash_encode</span>

<div class="viewcode-block" id="FeatureTable.category_encode"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.category_encode">[docs]</a>    <span class="k">def</span> <span class="nf">category_encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">freq_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order_by_freq</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">do_split</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">,</span> <span class="n">sort_for_array</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">keep_most_frequent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">broadcast</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Category encode the given columns.</span>

<span class="sd">        :param columns: str or a list of str, target columns to encode from string to index.</span>
<span class="sd">        :param freq_limit: int, dict or None. Categories with a count/frequency below freq_limit</span>
<span class="sd">               will be omitted from the encoding. Can be represented as either an integer,</span>
<span class="sd">               dict. For instance, 15, {&#39;col_4&#39;: 10, &#39;col_5&#39;: 2} etc. Default is None,</span>
<span class="sd">               and in this case all the categories that appear will be encoded.</span>
<span class="sd">        :param order_by_freq: boolean, whether the result StringIndex will assign smaller indices</span>
<span class="sd">               to values with more frequencies. Default is False and in this case frequency order</span>
<span class="sd">               may not be preserved when assigning indices.</span>
<span class="sd">        :param do_split: bool, whether need to split column value to array to encode string.</span>
<span class="sd">               Default is False.</span>
<span class="sd">        :param sep: str, a string representing a regular expression to split a column value.</span>
<span class="sd">               Default is &#39;,&#39;.</span>
<span class="sd">        :param sort_for_array: bool, whether need to sort array columns. Default is False.</span>
<span class="sd">        :param keep_most_frequent: bool, whether need to keep most frequent value as the</span>
<span class="sd">               column value. Default is False.</span>
<span class="sd">        :param broadcast: bool, whether need to broadcast index when encode string.</span>
<span class="sd">               Default is True.</span>

<span class="sd">        :return: A tuple of a new FeatureTable which transforms categorical features into unique</span>
<span class="sd">                 integer values, and a list of StringIndex for the mapping.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gen_string_idx</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">freq_limit</span><span class="o">=</span><span class="n">freq_limit</span><span class="p">,</span> <span class="n">order_by_freq</span><span class="o">=</span><span class="n">order_by_freq</span><span class="p">,</span>
                                      <span class="n">do_split</span><span class="o">=</span><span class="n">do_split</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">encode_string</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">do_split</span><span class="o">=</span><span class="n">do_split</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="n">sep</span><span class="p">,</span>
                                  <span class="n">sort_for_array</span><span class="o">=</span><span class="n">sort_for_array</span><span class="p">,</span>
                                  <span class="n">keep_most_frequent</span><span class="o">=</span><span class="n">keep_most_frequent</span><span class="p">,</span>
                                  <span class="n">broadcast</span><span class="o">=</span><span class="n">broadcast</span><span class="p">),</span> <span class="n">indices</span></div>

<div class="viewcode-block" id="FeatureTable.one_hot_encode"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.one_hot_encode">[docs]</a>    <span class="k">def</span> <span class="nf">one_hot_encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">sizes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">prefix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">keep_original_columns</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert categorical features into ont hot encodings.</span>
<span class="sd">        If the features are string, you should first call category_encode to encode them into</span>
<span class="sd">        indices before one hot encoding.</span>
<span class="sd">        For each input column, a one hot vector will be created expanding multiple output columns,</span>
<span class="sd">        with the value of each one hot column either 0 or 1.</span>
<span class="sd">        Note that you may only use one hot encoding on the columns with small dimensions</span>
<span class="sd">        for memory concerns.</span>

<span class="sd">        For example, for column &#39;x&#39; with size 5:</span>
<span class="sd">        Input:</span>
<span class="sd">        |x|</span>
<span class="sd">        |1|</span>
<span class="sd">        |3|</span>
<span class="sd">        |0|</span>
<span class="sd">        Output will contain 5 one hot columns:</span>
<span class="sd">        |prefix_0|prefix_1|prefix_2|prefix_3|prefix_4|</span>
<span class="sd">        |   0    |   1    |   0    |   0    |   0    |</span>
<span class="sd">        |   0    |   0    |   0    |   1    |   0    |</span>
<span class="sd">        |   1    |   0    |   0    |   0    |   0    |</span>

<span class="sd">        :param columns: str or a list of str, the target columns to be encoded.</span>
<span class="sd">        :param sizes: int or a list of int, the size(s) of the one hot vectors of the column(s).</span>
<span class="sd">               Default is None, and in this case, the sizes will be calculated by the maximum</span>
<span class="sd">               value(s) of the columns(s) + 1, namely the one hot vector will cover 0 to the</span>
<span class="sd">               maximum value.</span>
<span class="sd">               You are recommended to provided the sizes if they are known beforehand. If specified,</span>
<span class="sd">               sizes should have the same length as columns.</span>
<span class="sd">        :param prefix: str or a list of str, the prefix of the one hot columns for the input</span>
<span class="sd">               column(s). Default is None, and in this case, the prefix will be the input</span>
<span class="sd">               column names. If specified, prefix should have the same length as columns.</span>
<span class="sd">               The one hot columns for each input column will have column names:</span>
<span class="sd">               prefix_0, prefix_1, ... , prefix_maximum</span>
<span class="sd">        :param keep_original_columns: boolean, whether to keep the original index column(s) before</span>
<span class="sd">               the one hot encoding. Default is False, and in this case the original column(s)</span>
<span class="sd">               will be replaced by the one hot columns. If True, the one hot columns will be</span>
<span class="sd">               appended to each original column.</span>

<span class="sd">        :return: A new FeatureTable which transforms categorical indices into one hot encodings.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">sizes</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sizes</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="n">sizes</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Take the max of the column to make sure all values are within the range.</span>
            <span class="c1"># The vector size is 1 + max (i.e. from 0 to max).</span>
            <span class="n">sizes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">agg</span><span class="o">=</span><span class="s2">&quot;max&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">collect</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                     <span class="k">for</span> <span class="n">col_name</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">]</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">),</span>
                          <span class="s2">&quot;columns and sizes should have the same length&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">prefix</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prefix</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">prefix</span> <span class="o">=</span> <span class="p">[</span><span class="n">prefix</span><span class="p">]</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">prefix</span><span class="p">),</span>
                              <span class="s2">&quot;columns and prefix should have the same length&quot;</span><span class="p">)</span>
        <span class="n">data_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>

        <span class="k">def</span> <span class="nf">one_hot</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">sizes</span><span class="p">):</span>
            <span class="n">one_hot_vectors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sizes</span><span class="p">)):</span>
                <span class="n">one_hot_vector</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">one_hot_vector</span><span class="p">[</span><span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">one_hot_vectors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">one_hot_vector</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">one_hot_vectors</span>

        <span class="n">one_hot_udf</span> <span class="o">=</span> <span class="n">udf</span><span class="p">(</span><span class="k">lambda</span> <span class="n">columns</span><span class="p">:</span> <span class="n">one_hot</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">sizes</span><span class="p">),</span>
                          <span class="n">ArrayType</span><span class="p">(</span><span class="n">ArrayType</span><span class="p">(</span><span class="n">IntegerType</span><span class="p">())))</span>
        <span class="n">data_df</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&quot;friesian_onehot&quot;</span><span class="p">,</span> <span class="n">one_hot_udf</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">columns</span><span class="p">)))</span>

        <span class="n">all_columns</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">columns</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)):</span>
            <span class="n">col_name</span> <span class="o">=</span> <span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">col_idx</span> <span class="o">=</span> <span class="n">all_columns</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span>
            <span class="n">cols_before</span> <span class="o">=</span> <span class="n">all_columns</span><span class="p">[:</span><span class="n">col_idx</span><span class="p">]</span>
            <span class="n">cols_after</span> <span class="o">=</span> <span class="n">all_columns</span><span class="p">[</span><span class="n">col_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]</span>
            <span class="n">one_hot_prefix</span> <span class="o">=</span> <span class="n">prefix</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">prefix</span> <span class="k">else</span> <span class="n">col_name</span>
            <span class="n">one_hot_cols</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">sizes</span><span class="p">[</span><span class="n">i</span><span class="p">]):</span>
                <span class="n">one_hot_col</span> <span class="o">=</span> <span class="n">one_hot_prefix</span> <span class="o">+</span> <span class="s2">&quot;_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="n">one_hot_cols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">one_hot_col</span><span class="p">)</span>
                <span class="n">data_df</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">one_hot_col</span><span class="p">,</span>
                                             <span class="n">data_df</span><span class="o">.</span><span class="n">friesian_onehot</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">keep_original_columns</span><span class="p">:</span>
                <span class="n">all_columns</span> <span class="o">=</span> <span class="n">cols_before</span> <span class="o">+</span> <span class="p">[</span><span class="n">col_name</span><span class="p">]</span> <span class="o">+</span> <span class="n">one_hot_cols</span> <span class="o">+</span> <span class="n">cols_after</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">all_columns</span> <span class="o">=</span> <span class="n">cols_before</span> <span class="o">+</span> <span class="n">one_hot_cols</span> <span class="o">+</span> <span class="n">cols_after</span>
            <span class="n">data_df</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">all_columns</span><span class="p">)</span>
        <span class="n">data_df</span> <span class="o">=</span> <span class="n">data_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;friesian_onehot&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">data_df</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatureTable.gen_string_idx"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.gen_string_idx">[docs]</a>    <span class="k">def</span> <span class="nf">gen_string_idx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">freq_limit</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order_by_freq</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">do_split</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate unique index value of categorical features. The resulting index would</span>
<span class="sd">        start from 1 with 0 reserved for unknown features.</span>

<span class="sd">        :param columns: str, dict or a list of str, dict, target column(s) to generate StringIndex.</span>
<span class="sd">         dict is a mapping of source column names -&gt; target column name if needs to combine multiple</span>
<span class="sd">         source columns to generate index.</span>
<span class="sd">         For example: {&#39;src_cols&#39;:[&#39;a_user&#39;, &#39;b_user&#39;], &#39;col_name&#39;:&#39;user&#39;}.</span>
<span class="sd">        :param freq_limit: int, dict or None. Categories with a count/frequency below freq_limit</span>
<span class="sd">               will be omitted from the encoding. Can be represented as either an integer,</span>
<span class="sd">               dict. For instance, 15, {&#39;col_4&#39;: 10, &#39;col_5&#39;: 2} etc. Default is None,</span>
<span class="sd">               and in this case all the categories that appear will be encoded.</span>
<span class="sd">        :param order_by_freq: boolean, whether the result StringIndex will assign smaller indices</span>
<span class="sd">               to values with more frequencies. Default is False and in this case frequency order</span>
<span class="sd">               may not be preserved when assigning indices.</span>
<span class="sd">        :param do_split: bool, whether need to split column value to array to generate index.</span>
<span class="sd">        Default is False.</span>
<span class="sd">        :param sep: str, a string representing a regular expression to split a column value.</span>
<span class="sd">         Default is &#39;,&#39;.</span>

<span class="sd">        :return: A StringIndex or a list of StringIndex.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">columns</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                              <span class="s2">&quot;columns should be str or a list of str, but got None.&quot;</span><span class="p">)</span>
        <span class="n">is_single_column</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">is_single_column</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
        <span class="n">src_columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="s1">&#39;src_cols&#39;</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
                    <span class="n">src_columns</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="s1">&#39;src_cols&#39;</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">src_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="n">check_col_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">src_columns</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">freq_limit</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq_limit</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">freq_limit</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">freq_limit</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq_limit</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">freq_limit</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">freq_limit</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="s2">&quot;freq_limit only supports int, dict or None, but get &quot;</span> <span class="o">+</span>
                                  <span class="n">freq_limit</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">out_columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">simple_columns</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">df_id_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="c1"># union column</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">if</span> <span class="s1">&#39;src_cols&#39;</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
                    <span class="n">src_cols</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="s1">&#39;src_cols&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                                      <span class="s2">&quot;Union columns must has argument &#39;src_cols&#39;&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="s1">&#39;col_name&#39;</span> <span class="ow">in</span> <span class="n">c</span><span class="p">:</span>
                    <span class="n">col_name</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="s1">&#39;col_name&#39;</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">col_name</span> <span class="o">=</span> <span class="n">src_cols</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_union&#39;</span>
                <span class="c1"># process simple columns</span>
                <span class="k">if</span> <span class="n">simple_columns</span><span class="p">:</span>
                    <span class="n">simple_df_id_list</span> <span class="o">=</span> <span class="n">generate_string_idx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">simple_columns</span><span class="p">,</span>
                                                            <span class="n">freq_limit</span><span class="p">,</span> <span class="n">order_by_freq</span><span class="p">)</span>
                    <span class="n">df_id_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">simple_df_id_list</span><span class="p">)</span>
                    <span class="n">simple_columns</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># process union columns</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">src_c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">src_cols</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">dict_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">src_c</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">col_name</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">dict_df</span> <span class="o">=</span> <span class="n">dict_df</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">src_c</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">col_name</span><span class="p">)))</span>
                <span class="n">union_id_list</span> <span class="o">=</span> <span class="n">generate_string_idx</span><span class="p">(</span><span class="n">dict_df</span><span class="p">,</span> <span class="p">[</span><span class="n">col_name</span><span class="p">],</span>
                                                    <span class="n">freq_limit</span><span class="p">,</span> <span class="n">order_by_freq</span><span class="p">)</span>
                <span class="n">df_id_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">union_id_list</span><span class="p">)</span>
                <span class="n">out_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">col_name</span><span class="p">)</span>
            <span class="c1"># single column</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">do_split</span><span class="p">:</span>
                    <span class="n">dict_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">col</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
                    <span class="n">dict_df</span> <span class="o">=</span> <span class="n">dict_df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">explode</span><span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">sep</span><span class="p">)))</span>
                    <span class="n">split_id_list</span> <span class="o">=</span> <span class="n">generate_string_idx</span><span class="p">(</span><span class="n">dict_df</span><span class="p">,</span> <span class="p">[</span><span class="n">c</span><span class="p">],</span> <span class="n">freq_limit</span><span class="p">,</span> <span class="n">order_by_freq</span><span class="p">)</span>
                    <span class="n">df_id_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">split_id_list</span><span class="p">)</span>
                    <span class="n">out_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">simple_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
                    <span class="n">out_columns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">simple_columns</span><span class="p">:</span>
            <span class="n">simple_df_id_list</span> <span class="o">=</span> <span class="n">generate_string_idx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">simple_columns</span><span class="p">,</span>
                                                    <span class="n">freq_limit</span><span class="p">,</span> <span class="n">order_by_freq</span><span class="p">)</span>
            <span class="n">df_id_list</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">simple_df_id_list</span><span class="p">)</span>

        <span class="n">string_idx_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">StringIndex</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
                                   <span class="nb">zip</span><span class="p">(</span><span class="n">df_id_list</span><span class="p">,</span> <span class="n">out_columns</span><span class="p">)))</span>

        <span class="c1"># If input is a single column (not a list), then the output would be a single StringIndex.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">string_idx_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">is_single_column</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">string_idx_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">string_idx_list</span></div>

    <span class="k">def</span> <span class="nf">_clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>

<div class="viewcode-block" id="FeatureTable.min_max_scale"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.min_max_scale">[docs]</a>    <span class="k">def</span> <span class="nf">min_max_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="nb">min</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rescale each column individually to a common range [min, max] linearly using</span>
<span class="sd">        column summary statistics, which is also known as min-max normalization or rescaling.</span>

<span class="sd">        :param columns: str or a list of str, the column(s) to be rescaled.</span>
<span class="sd">        :param min: int, the lower bound after transformation, shared by all columns.</span>
<span class="sd">                    Default is 0.0.</span>
<span class="sd">        :param max: int, the upper bound after transformation, shared by all columns.</span>
<span class="sd">                    Default is 1.0.</span>

<span class="sd">        :return: A tuple of a new FeatureTable with rescaled column(s), and a dict of the</span>
<span class="sd">                 original min and max values of the input column(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">str_to_list</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>
        <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">dtypes</span><span class="p">]</span>
        <span class="n">scalar_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">))</span>
                       <span class="k">if</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;int&quot;</span> <span class="ow">or</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;bigint&quot;</span>
                       <span class="ow">or</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;float&quot;</span> <span class="ow">or</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;double&quot;</span><span class="p">]</span>
        <span class="n">array_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">))</span>
                      <span class="k">if</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;array&lt;int&gt;&quot;</span> <span class="ow">or</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;array&lt;bigint&gt;&quot;</span>
                      <span class="ow">or</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;array&lt;float&gt;&quot;</span> <span class="ow">or</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;array&lt;double&gt;&quot;</span><span class="p">]</span>
        <span class="n">vector_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">))</span> <span class="k">if</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;vector&quot;</span><span class="p">]</span>

        <span class="n">min_max_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">tolist</span> <span class="o">=</span> <span class="n">udf</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">ArrayType</span><span class="p">(</span><span class="n">DoubleType</span><span class="p">()))</span>

        <span class="k">if</span> <span class="n">scalar_cols</span><span class="p">:</span>
            <span class="n">assembler</span> <span class="o">=</span> <span class="n">VectorAssembler</span><span class="p">(</span><span class="n">inputCols</span><span class="o">=</span><span class="n">scalar_cols</span><span class="p">,</span> <span class="n">outputCol</span><span class="o">=</span><span class="s2">&quot;vect&quot;</span><span class="p">)</span>

            <span class="c1"># MinMaxScaler Transformation</span>
            <span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="nb">max</span><span class="p">,</span> <span class="n">inputCol</span><span class="o">=</span><span class="s2">&quot;vect&quot;</span><span class="p">,</span> <span class="n">outputCol</span><span class="o">=</span><span class="s2">&quot;scaled&quot;</span><span class="p">)</span>

            <span class="c1"># Pipeline of VectorAssembler and MinMaxScaler</span>
            <span class="n">pipeline</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">(</span><span class="n">stages</span><span class="o">=</span><span class="p">[</span><span class="n">assembler</span><span class="p">,</span> <span class="n">scaler</span><span class="p">])</span>

            <span class="c1"># Fitting pipeline on DataFrame</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">pipeline</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">)</span> \
                <span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="s2">&quot;scaled_list&quot;</span><span class="p">,</span> <span class="n">tolist</span><span class="p">(</span><span class="n">pyspark_col</span><span class="p">(</span><span class="s2">&quot;scaled&quot;</span><span class="p">)))</span> \
                <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;vect&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;scaled&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">scalar_cols</span><span class="p">)):</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">scalar_cols</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pyspark_col</span><span class="p">(</span><span class="s2">&quot;scaled_list&quot;</span><span class="p">)[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;scaled_list&quot;</span><span class="p">)</span>

            <span class="c1"># cast to float</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">scalar_cols</span><span class="p">:</span>
                <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">pyspark_col</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;float&quot;</span><span class="p">))</span>

            <span class="n">min_list</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">originalMin</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">max_list</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">stages</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">originalMax</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">min_max</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">min_list</span><span class="p">,</span> <span class="n">max_list</span><span class="p">)):</span>
                <span class="n">min_max_dict</span><span class="p">[</span><span class="n">scalar_cols</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">=</span> <span class="n">min_max</span>

        <span class="kn">from</span> <span class="nn">pyspark.ml.linalg</span> <span class="k">import</span> <span class="n">Vectors</span><span class="p">,</span> <span class="n">VectorUDT</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">array_cols</span><span class="p">:</span>
            <span class="n">list_to_vector_udf</span> <span class="o">=</span> <span class="n">udf</span><span class="p">(</span><span class="k">lambda</span> <span class="n">l</span><span class="p">:</span> <span class="n">Vectors</span><span class="o">.</span><span class="n">dense</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">VectorUDT</span><span class="p">())</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">list_to_vector_udf</span><span class="p">(</span><span class="n">pyspark_col</span><span class="p">(</span><span class="n">c</span><span class="p">)))</span>
            <span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="nb">max</span><span class="p">,</span> <span class="n">inputCol</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">outputCol</span><span class="o">=</span><span class="s2">&quot;scaled&quot;</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">tolist</span><span class="p">(</span><span class="s2">&quot;scaled&quot;</span><span class="p">))</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;scaled&quot;</span><span class="p">)</span>
            <span class="n">min_max_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">originalMin</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                               <span class="n">model</span><span class="o">.</span><span class="n">originalMax</span><span class="o">.</span><span class="n">toArray</span><span class="p">()</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">vector_cols</span><span class="p">:</span>
            <span class="n">scaler</span> <span class="o">=</span> <span class="n">MinMaxScaler</span><span class="p">(</span><span class="nb">min</span><span class="o">=</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="o">=</span><span class="nb">max</span><span class="p">,</span> <span class="n">inputCol</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">outputCol</span><span class="o">=</span><span class="s2">&quot;scaled&quot;</span><span class="p">)</span>
            <span class="n">model</span> <span class="o">=</span> <span class="n">scaler</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df</span><span class="p">)</span><span class="o">.</span><span class="n">withColumnRenamed</span><span class="p">(</span><span class="s2">&quot;scaled&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
            <span class="nb">min</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">originalMin</span>
            <span class="nb">max</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">originalMax</span>
            <span class="n">min_max_dict</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">,</span> <span class="nb">max</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">df</span><span class="p">),</span> <span class="n">min_max_dict</span></div>

<div class="viewcode-block" id="FeatureTable.transform_min_max_scale"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.transform_min_max_scale">[docs]</a>    <span class="k">def</span> <span class="nf">transform_min_max_scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">min_max_dict</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rescale each column individually with the given [min, max] range of each column.</span>

<span class="sd">        :param columns: str or a list of str, the column(s) to be rescaled.</span>
<span class="sd">        :param min_max_dict: dict, the key is the column name, and the value is the</span>
<span class="sd">               tuple of min and max values of this column.</span>

<span class="sd">        :return: A new FeatureTable with rescaled column(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">str_to_list</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">)</span>
        <span class="n">types</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">columns</span><span class="p">)</span><span class="o">.</span><span class="n">dtypes</span><span class="p">]</span>
        <span class="n">scalar_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">))</span>
                       <span class="k">if</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;int&quot;</span> <span class="ow">or</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;bigint&quot;</span>
                       <span class="ow">or</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;float&quot;</span> <span class="ow">or</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;double&quot;</span><span class="p">]</span>
        <span class="n">array_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">))</span>
                      <span class="k">if</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;array&lt;int&gt;&quot;</span> <span class="ow">or</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;array&lt;bigint&gt;&quot;</span>
                      <span class="ow">or</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;array&lt;float&gt;&quot;</span> <span class="ow">or</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;array&lt;double&gt;&quot;</span><span class="p">]</span>
        <span class="n">vector_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">))</span> <span class="k">if</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;vector&quot;</span><span class="p">]</span>

        <span class="n">tbl</span> <span class="o">=</span> <span class="bp">self</span>

        <span class="k">def</span> <span class="nf">normalize_array</span><span class="p">(</span><span class="n">c_min</span><span class="p">,</span> <span class="n">c_max</span><span class="p">):</span>

            <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="n">np_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                <span class="n">np_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c_min</span><span class="p">)</span>
                <span class="n">np_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c_max</span><span class="p">)</span>
                <span class="n">normalized</span> <span class="o">=</span> <span class="p">(</span><span class="n">np_x</span> <span class="o">-</span> <span class="n">np_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">np_max</span> <span class="o">-</span> <span class="n">np_min</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">normalized</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

            <span class="k">return</span> <span class="n">normalize</span>

        <span class="k">def</span> <span class="nf">normalize_scalar_vector</span><span class="p">(</span><span class="n">c_min</span><span class="p">,</span> <span class="n">c_max</span><span class="p">):</span>
            <span class="k">def</span> <span class="nf">normalize</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">c_min</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">c_max</span> <span class="o">-</span> <span class="n">c_min</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">normalize</span>

        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">scalar_cols</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">min_max_dict</span><span class="p">:</span>
                <span class="n">col_min</span><span class="p">,</span> <span class="n">col_max</span> <span class="o">=</span> <span class="n">min_max_dict</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
                <span class="n">tbl</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">normalize_scalar_vector</span><span class="p">(</span><span class="n">col_min</span><span class="p">,</span> <span class="n">col_max</span><span class="p">),</span> <span class="s2">&quot;float&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">array_cols</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">min_max_dict</span><span class="p">:</span>
                <span class="n">col_min</span><span class="p">,</span> <span class="n">col_max</span> <span class="o">=</span> <span class="n">min_max_dict</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
                <span class="n">tbl</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">normalize_array</span><span class="p">(</span><span class="n">col_min</span><span class="p">,</span> <span class="n">col_max</span><span class="p">),</span> <span class="s2">&quot;array&lt;float&gt;&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">vector_cols</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">min_max_dict</span><span class="p">:</span>
                <span class="n">col_min</span><span class="p">,</span> <span class="n">col_max</span> <span class="o">=</span> <span class="n">min_max_dict</span><span class="p">[</span><span class="n">column</span><span class="p">]</span>
                <span class="n">tbl</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span>
                                <span class="n">normalize_scalar_vector</span><span class="p">(</span><span class="n">col_min</span><span class="p">,</span> <span class="n">col_max</span><span class="p">),</span> <span class="s2">&quot;vector&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">tbl</span></div>

<div class="viewcode-block" id="FeatureTable.add_negative_samples"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.add_negative_samples">[docs]</a>    <span class="k">def</span> <span class="nf">add_negative_samples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item_size</span><span class="p">,</span> <span class="n">item_col</span><span class="o">=</span><span class="s2">&quot;item&quot;</span><span class="p">,</span> <span class="n">label_col</span><span class="o">=</span><span class="s2">&quot;label&quot;</span><span class="p">,</span> <span class="n">neg_num</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate negative records for each record in the FeatureTable. All the records in the</span>
<span class="sd">        original FeatureTable will be treated as positive samples with value 1 for label_col</span>
<span class="sd">        and the negative samples will be randomly generated with value 0 for label_col.</span>

<span class="sd">        :param item_size: int, the total number of items in the FeatureTable.</span>
<span class="sd">        :param item_col: str, the name of the item column. Whether the record is positive or</span>
<span class="sd">               negative will be based on this column. Default is &#39;item&#39;.</span>
<span class="sd">        :param label_col: str, the name of the label column. Default is &#39;label&#39;.</span>
<span class="sd">        :param neg_num: int, the number of negative records for each positive record. Default is 1.</span>

<span class="sd">        :return: A new FeatureTable with negative samples.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">add_negative_samples</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">item_size</span><span class="p">,</span> <span class="n">item_col</span><span class="p">,</span> <span class="n">label_col</span><span class="p">,</span> <span class="n">neg_num</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatureTable.add_hist_seq"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.add_hist_seq">[docs]</a>    <span class="k">def</span> <span class="nf">add_hist_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">user_col</span><span class="p">,</span> <span class="n">sort_col</span><span class="o">=</span><span class="s1">&#39;time&#39;</span><span class="p">,</span>
                     <span class="n">min_len</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">max_len</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">num_seqs</span><span class="o">=</span><span class="mi">2147483647</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a column of history visits of each user.</span>

<span class="sd">        :param cols: str or a list of str, the column(s) to be treated as histories.</span>
<span class="sd">        :param user_col: str, the column to be treated as the user.</span>
<span class="sd">        :param sort_col: str, the column to sort by for each user. Default is &#39;time&#39;.</span>
<span class="sd">        :param min_len: int, the minimal length of a history sequence. Default is 1.</span>
<span class="sd">        :param max_len: int, the maximal length of a history sequence. Default is 100.</span>
<span class="sd">        :param num_seqs: int, default is 2147483647 (maximum value of 4-byte integer),</span>
<span class="sd">               which means to to keep all the histories.</span>
<span class="sd">               You can set num_seqs=1 to only keep the last history.</span>

<span class="sd">        :return: A new FeatureTable with history sequences.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">str_to_list</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="s2">&quot;cols&quot;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">add_hist_seq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">user_col</span><span class="p">,</span> <span class="n">sort_col</span><span class="p">,</span> <span class="n">min_len</span><span class="p">,</span> <span class="n">max_len</span><span class="p">,</span> <span class="n">num_seqs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatureTable.add_neg_hist_seq"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.add_neg_hist_seq">[docs]</a>    <span class="k">def</span> <span class="nf">add_neg_hist_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item_size</span><span class="p">,</span> <span class="n">item_history_col</span><span class="p">,</span> <span class="n">neg_num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a list of negative samples for each item in the history sequence.</span>

<span class="sd">        :param item_size: int, the total number of items in the FeatureTable.</span>
<span class="sd">        :param item_history_col: str, the history column to generate negative samples.</span>
<span class="sd">        :param neg_num: int, the number of negative items for each history (positive) item.</span>

<span class="sd">        :return: A new FeatureTable with negative history sequences.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">add_neg_hist_seq</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">item_size</span><span class="p">,</span> <span class="n">item_history_col</span><span class="p">,</span> <span class="n">neg_num</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatureTable.mask"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.mask">[docs]</a>    <span class="k">def</span> <span class="nf">mask</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mask_cols</span><span class="p">,</span> <span class="n">seq_len</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add mask on specified column(s).</span>

<span class="sd">        :param mask_cols: str or a list of str, the column(s) to be masked with 1s and 0s.</span>
<span class="sd">               Each column should be of list type.</span>
<span class="sd">        :param seq_len: int, the length of the masked column. Default is 100.</span>

<span class="sd">        :return: A new FeatureTable with masked columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mask_cols</span> <span class="o">=</span> <span class="n">str_to_list</span><span class="p">(</span><span class="n">mask_cols</span><span class="p">,</span> <span class="s2">&quot;mask_cols&quot;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">mask_cols</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatureTable.pad"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.pad">[docs]</a>    <span class="k">def</span> <span class="nf">pad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">seq_len</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">mask_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mask_token</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add padding on specified column(s).</span>

<span class="sd">        :param cols: str or a list of str, the column(s) to be padded with mask_tokens. Each column</span>
<span class="sd">               should be of list type.</span>
<span class="sd">        :param seq_len: int, the length to be padded to for cols. Default is 100.</span>
<span class="sd">        :param mask_cols: str or a list of str, the column(s) to be masked with 1s and 0s.</span>
<span class="sd">        :param mask_token: numeric types or str, should be consistent with element&#39;s type of cols.</span>
<span class="sd">               Default is 0.</span>

<span class="sd">        :return: A new FeatureTable with padded columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">str_to_list</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="s2">&quot;cols&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mask_cols</span><span class="p">:</span>
            <span class="n">mask_cols</span> <span class="o">=</span> <span class="n">str_to_list</span><span class="p">(</span><span class="n">mask_cols</span><span class="p">,</span> <span class="s2">&quot;mask_cols&quot;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">pad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">seq_len</span><span class="p">,</span> <span class="n">mask_cols</span><span class="p">,</span> <span class="n">mask_token</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatureTable.apply"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_col</span><span class="p">,</span> <span class="n">out_col</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s2">&quot;string&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Transform a FeatureTable using a user-defined Python function.</span>

<span class="sd">        :param in_col: str or a list of str, the column(s) to be transformed.</span>
<span class="sd">        :param out_col: str, the name of output column.</span>
<span class="sd">        :param func: The Python function with in_col as input and out_col.</span>
<span class="sd">               When in_col is a list of str, func should take a list as input,</span>
<span class="sd">               and in this case you are generating out_col given multiple</span>
<span class="sd">               input columns.</span>
<span class="sd">        :param dtype: str, the data type of out_col. Default is string type.</span>

<span class="sd">        :return: A new FeatureTable after column transformation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">udf_func</span> <span class="o">=</span> <span class="n">udf</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">out_col</span><span class="p">,</span> <span class="nb">str</span><span class="p">),</span> <span class="s2">&quot;out_col must be a single column&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">in_col</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">out_col</span><span class="p">,</span> <span class="n">udf_func</span><span class="p">(</span><span class="n">pyspark_col</span><span class="p">(</span><span class="n">in_col</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">in_col</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span>
                              <span class="s2">&quot;in_col must be a single column of a list of columns&quot;</span><span class="p">)</span>
            <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">out_col</span><span class="p">,</span> <span class="n">udf_func</span><span class="p">(</span><span class="n">array</span><span class="p">(</span><span class="n">in_col</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatureTable.join"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.join">[docs]</a>    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">table</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">lsuffix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rsuffix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Join a FeatureTable with another FeatureTable.</span>

<span class="sd">        :param table: A FeatureTable.</span>
<span class="sd">        :param on: str or a list of str, the column(s) to join.</span>
<span class="sd">        :param how: str, default is inner. Must be one of: inner, cross, outer, full,</span>
<span class="sd">               fullouter, full_outer, left, leftouter, left_outer, right, rightouter,</span>
<span class="sd">               right_outer, semi, leftsemi, left_semi, anti, leftanti and left_anti.</span>
<span class="sd">        :param lsuffix: The suffix to use for the original Table&#39;s overlapping columns.</span>
<span class="sd">        :param rsuffix: The suffix to use for the input Table&#39;s overlapping columns.</span>

<span class="sd">        :return: A joined FeatureTable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">Table</span><span class="p">),</span> <span class="s2">&quot;the joined table should be a Table&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">on</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">on</span> <span class="o">=</span> <span class="p">[</span><span class="n">on</span><span class="p">]</span>
        <span class="n">overlap_columns</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">names</span><span class="p">)</span><span class="o">.</span>
                               <span class="n">intersection</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">schema</span><span class="o">.</span><span class="n">names</span><span class="p">))</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="n">on</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">lsuffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">{</span><span class="n">column</span><span class="p">:</span> <span class="n">column</span> <span class="o">+</span> <span class="n">lsuffix</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">overlap_columns</span><span class="p">}</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rsuffix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">{</span><span class="n">column</span><span class="p">:</span> <span class="n">column</span> <span class="o">+</span> <span class="n">rsuffix</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">overlap_columns</span><span class="p">}</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>
        <span class="n">joined_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">table</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">on</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="n">how</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">joined_df</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatureTable.add_value_features"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.add_value_features">[docs]</a>    <span class="k">def</span> <span class="nf">add_value_features</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">dict_tbl</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Add features based on key columns and the key value Table.</span>
<span class="sd">         For each column in columns, it adds a value column using key-value pairs from dict_tbl.</span>

<span class="sd">         :param columns: str or a list of str, the key columns in the original FeatureTable.</span>
<span class="sd">         :param dict_tbl: A Table for the key value mapping.</span>
<span class="sd">         :param key: str, the name of the key column in dict_tbl.</span>
<span class="sd">         :param value: str, the name of value column in dict_tbl.</span>

<span class="sd">         :return: A new FeatureTable with value columns.</span>
<span class="sd">         &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span>
                          <span class="n">f</span><span class="s2">&quot;columns should be str or a list of str, but get a {str(type(columns))}&quot;</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">add_value_features</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">dict_tbl</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatureTable.reindex"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.reindex">[docs]</a>    <span class="k">def</span> <span class="nf">reindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[],</span> <span class="n">index_tbls</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Replace the value using index_dicts for each col in columns, set 0 for default</span>

<span class="sd">        :param columns: str of a list of str</span>
<span class="sd">        :param dict_tbls: table or list of tables, each one has a mapping from old index to new one</span>

<span class="sd">        :return: FeatureTable</span>
<span class="sd">         &quot;&quot;&quot;</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">str_to_list</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index_tbls</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">index_tbls</span> <span class="o">=</span> <span class="p">[</span><span class="n">index_tbls</span><span class="p">]</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">index_tbls</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span>
                          <span class="s2">&quot;index_dicts should be table or a list of table,&quot;</span>
                          <span class="n">f</span><span class="s2">&quot; but get a {str(type(index_tbls))}&quot;</span><span class="p">)</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">index_tbls</span><span class="p">),</span>
                          <span class="s2">&quot;each column of columns should have one corresponding index_dict&quot;</span><span class="p">)</span>

        <span class="n">tbl</span> <span class="o">=</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">columns</span><span class="p">):</span>
            <span class="n">tbl</span> <span class="o">=</span> <span class="n">tbl</span><span class="o">.</span><span class="n">add_value_features</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">index_tbls</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="n">c</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">c</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tbl</span></div>

<div class="viewcode-block" id="FeatureTable.gen_reindex_mapping"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.gen_reindex_mapping">[docs]</a>    <span class="k">def</span> <span class="nf">gen_reindex_mapping</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[],</span> <span class="n">freq_limit</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a mapping from old index to new one based on popularity count on descending order</span>
<span class="sd">         :param columns: str or a list of str</span>
<span class="sd">         :param freq_limit: int, dict or None. Indices with a count below freq_limit</span>
<span class="sd">               will be omitted. Can be represented as either an integer or dict.</span>
<span class="sd">               For instance, 15, {&#39;col_4&#39;: 10, &#39;col_5&#39;: 2} etc. Default is 10,</span>

<span class="sd">        :return: a list of FeatureTables, each table has a mapping from old index to new index</span>
<span class="sd">                new index starts from 1, save 0 for default</span>
<span class="sd">         &quot;&quot;&quot;</span>
        <span class="n">str_to_list</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">freq_limit</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">freq_limit</span> <span class="o">=</span> <span class="p">{</span><span class="n">col</span><span class="p">:</span> <span class="n">freq_limit</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">}</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">freq_limit</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span>
                          <span class="n">f</span><span class="s2">&quot;freq_limit should be int or dict, but get a {str(type(freq_limit))}&quot;</span><span class="p">)</span>
        <span class="n">index_tbls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">c_count</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">agg</span><span class="o">=</span><span class="p">{</span><span class="n">c</span><span class="p">:</span> <span class="s2">&quot;count&quot;</span><span class="p">})</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
                <span class="p">{</span><span class="s2">&quot;count(&quot;</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span> <span class="s2">&quot;)&quot;</span><span class="p">:</span> <span class="s2">&quot;count&quot;</span><span class="p">})</span>
            <span class="n">c_count</span> <span class="o">=</span> <span class="n">c_count</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">pyspark_col</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">freq_limit</span><span class="p">[</span><span class="n">c</span><span class="p">])</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">Window</span><span class="o">.</span><span class="n">orderBy</span><span class="p">(</span><span class="n">desc</span><span class="p">(</span><span class="s2">&quot;count&quot;</span><span class="p">))</span>
            <span class="n">index_df</span> <span class="o">=</span> <span class="n">c_count</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">c</span> <span class="o">+</span> <span class="s2">&quot;_new&quot;</span><span class="p">,</span> <span class="n">row_number</span><span class="p">()</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">w</span><span class="p">))</span>
            <span class="n">index_tbl</span> <span class="o">=</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">index_df</span><span class="p">)</span><span class="o">.</span><span class="n">select</span><span class="p">([</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span> <span class="o">+</span> <span class="s2">&quot;_new&quot;</span><span class="p">])</span>
            <span class="n">index_tbls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index_tbl</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">index_tbls</span> <span class="o">=</span> <span class="n">index_tbls</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">index_tbls</span></div>

<div class="viewcode-block" id="FeatureTable.group_by"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.group_by">[docs]</a>    <span class="k">def</span> <span class="nf">group_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[],</span> <span class="n">agg</span><span class="o">=</span><span class="s2">&quot;count&quot;</span><span class="p">,</span> <span class="n">join</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Group the Table with specified columns and then run aggregation. Optionally join the result</span>
<span class="sd">        with the original Table.</span>

<span class="sd">        :param columns: str or a list of str. Columns to group the Table. If it is an empty list,</span>
<span class="sd">               aggregation is run directly without grouping. Default is [].</span>
<span class="sd">        :param agg: str, list or dict. Aggregate functions to be applied to grouped Table.</span>
<span class="sd">               Default is &quot;count&quot;.</span>
<span class="sd">               Supported aggregate functions are: &quot;max&quot;, &quot;min&quot;, &quot;count&quot;, &quot;sum&quot;, &quot;avg&quot;, &quot;mean&quot;,</span>
<span class="sd">               &quot;sumDistinct&quot;, &quot;stddev&quot;, &quot;stddev_pop&quot;, &quot;variance&quot;, &quot;var_pop&quot;, &quot;skewness&quot;, &quot;kurtosis&quot;,</span>
<span class="sd">               &quot;collect_list&quot;, &quot;collect_set&quot;, &quot;approx_count_distinct&quot;, &quot;first&quot;, &quot;last&quot;.</span>
<span class="sd">               If agg is a str, then agg is the aggregate function and the aggregation is performed</span>
<span class="sd">               on all columns that are not in `columns`.</span>
<span class="sd">               If agg is a list of str, then agg is a list of aggregate function and the aggregation</span>
<span class="sd">               is performed on all columns that are not in `columns`.</span>
<span class="sd">               If agg is a single dict mapping from str to str, then the key is the column</span>
<span class="sd">               to perform aggregation on, and the value is the aggregate function.</span>
<span class="sd">               If agg is a single dict mapping from str to list, then the key is the</span>
<span class="sd">               column to perform aggregation on, and the value is list of aggregate functions.</span>

<span class="sd">               Examples:</span>
<span class="sd">               agg=&quot;sum&quot;</span>
<span class="sd">               agg=[&quot;last&quot;, &quot;stddev&quot;]</span>
<span class="sd">               agg={&quot;*&quot;:&quot;count&quot;}</span>
<span class="sd">               agg={&quot;col_1&quot;:&quot;sum&quot;, &quot;col_2&quot;:[&quot;count&quot;, &quot;mean&quot;]}</span>
<span class="sd">        :param join: boolean. If True, join the aggregation result with original Table.</span>

<span class="sd">        :return: A new Table with aggregated column fields.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="n">columns</span><span class="p">]</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="s2">&quot;columns should be str or a list of str&quot;</span><span class="p">)</span>
        <span class="n">grouped_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">agg_exprs_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">agg_column</span><span class="p">:</span> <span class="n">agg</span> <span class="k">for</span> <span class="n">agg_column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span>
                              <span class="k">if</span> <span class="n">agg_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">}</span>
            <span class="n">agg_df</span> <span class="o">=</span> <span class="n">grouped_data</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">agg_exprs_dict</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">agg_exprs_list</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span> <span class="n">agg</span><span class="p">:</span>
                <span class="n">stat_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">stat</span><span class="p">)</span>
                <span class="n">agg_exprs_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">stat_func</span><span class="p">(</span><span class="n">agg_column</span><span class="p">)</span> <span class="k">for</span> <span class="n">agg_column</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span>
                                   <span class="k">if</span> <span class="n">agg_column</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">]</span>
            <span class="n">agg_df</span> <span class="o">=</span> <span class="n">grouped_data</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="o">*</span><span class="n">agg_exprs_list</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">agg</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">agg_column</span><span class="p">,</span> <span class="n">stats</span> <span class="ow">in</span> <span class="n">agg</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">agg_df</span> <span class="o">=</span> <span class="n">grouped_data</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="n">agg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">agg_exprs_list</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">agg_column</span><span class="p">,</span> <span class="n">stats</span> <span class="ow">in</span> <span class="n">agg</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="n">stats</span> <span class="o">=</span> <span class="p">[</span><span class="n">stats</span><span class="p">]</span>
                    <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">stats</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span>
                                      <span class="s2">&quot;value in agg should be str or a list of str&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">stat</span> <span class="ow">in</span> <span class="n">stats</span><span class="p">:</span>
                        <span class="n">stat_func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">F</span><span class="p">,</span> <span class="n">stat</span><span class="p">)</span>
                        <span class="n">agg_exprs_list</span> <span class="o">+=</span> <span class="p">[</span><span class="n">stat_func</span><span class="p">(</span><span class="n">agg_column</span><span class="p">)]</span>
                <span class="n">agg_df</span> <span class="o">=</span> <span class="n">grouped_data</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="o">*</span><span class="n">agg_exprs_list</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                              <span class="s2">&quot;agg should be str, list of str, or dict&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">join</span><span class="p">:</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;columns can not be empty if join is True&quot;</span><span class="p">)</span>
            <span class="n">result_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">agg_df</span><span class="p">,</span> <span class="n">on</span><span class="o">=</span><span class="n">columns</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">result_df</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">agg_df</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatureTable.target_encode"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.target_encode">[docs]</a>    <span class="k">def</span> <span class="nf">target_encode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cat_cols</span><span class="p">,</span> <span class="n">target_cols</span><span class="p">,</span> <span class="n">target_mean</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">smooth</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">kfold</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                      <span class="n">fold_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fold_col</span><span class="o">=</span><span class="s2">&quot;__fold__&quot;</span><span class="p">,</span> <span class="n">drop_cat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">drop_fold</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                      <span class="n">out_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For each categorical column or column group in cat_cols, calculate the mean of target</span>
<span class="sd">        columns in target_cols and encode the FeatureTable with the target mean(s) to generate</span>
<span class="sd">        new features.</span>

<span class="sd">        :param cat_cols: str, a list of str or a nested list of str. Categorical column(s) or column</span>
<span class="sd">               group(s) to target encode. To encode categorical column(s), cat_cols should be a str</span>
<span class="sd">               or a list of str. To encode categorical column group(s), cat_cols should be a nested</span>
<span class="sd">               list of str.</span>
<span class="sd">        :param target_cols: str or a list of str. Numeric target column(s) to calculate the mean.</span>
<span class="sd">               If target_cols is a list, then each target_col would be used separately to encode the</span>
<span class="sd">               cat_cols.</span>
<span class="sd">        :param target_mean: dict of {target column : mean} to provides global mean of target</span>
<span class="sd">               column(s) if known beforehand to save calculation. Default is None and in this case</span>
<span class="sd">               the global mean(s) would be calculated on demand.</span>
<span class="sd">        :param smooth: int. The mean of each category is smoothed by the overall mean. Default is</span>
<span class="sd">               20.</span>
<span class="sd">        :param kfold: int. Specifies number of folds for cross validation. The mean values within</span>
<span class="sd">               the i-th fold are calculated with data from all other folds. If kfold is 1,</span>
<span class="sd">               global-mean statistics are applied; otherwise, cross validation is applied. Default</span>
<span class="sd">               is 2.</span>
<span class="sd">        :param fold_seed: int. Random seed used for generating folds. Default is None and in this</span>
<span class="sd">               case folds will be generated with row number in each partition.</span>
<span class="sd">        :param fold_col: str. Name of integer column used for splitting folds. If fold_col exists</span>
<span class="sd">               in the FeatureTable, then this column is used; otherwise, it is randomly generated</span>
<span class="sd">               within the range [0, kfold). Default is &quot;__fold__&quot;.</span>
<span class="sd">        :param drop_cat: boolean, whether to drop the original categorical columns.</span>
<span class="sd">               Default is False.</span>
<span class="sd">        :param drop_fold: boolean, whether to drop the fold column. Default is True.</span>
<span class="sd">        :param out_cols: str, a list of str or a nested list of str. When both cat_cols and</span>
<span class="sd">               target_cols has only one element, out_cols can be a single str. When cat_cols or</span>
<span class="sd">               target_cols has only one element, out_cols can be a list of str, and each element</span>
<span class="sd">               in out_cols corresponds to an element in target_cols or cat_cols. When it is a</span>
<span class="sd">               nested list of str, each inner list corresponds to the categorical column in the</span>
<span class="sd">               same position of cat_cols. Each element in the inner list corresponds to the target</span>
<span class="sd">               column in the same position of target_cols. Default to be None and in this case the</span>
<span class="sd">               output column will be cat_col + &quot;_te_&quot; + target_col.</span>

<span class="sd">        :return: A tuple of a new FeatureTable with target encoded columns and a list of TargetCodes</span>
<span class="sd">                 which contains the target encode values of the whole FeatureTable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">kfold</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="ow">and</span> <span class="n">kfold</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span>
                          <span class="s2">&quot;kfold should be an integer larger than 0&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cat_cols</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">cat_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">cat_cols</span><span class="p">]</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">cat_cols</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="s2">&quot;cat_cols should be str or list&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">cat_col</span> <span class="ow">in</span> <span class="n">cat_cols</span><span class="p">:</span>
            <span class="n">check_col_str_list_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">cat_col</span><span class="p">,</span> <span class="s2">&quot;cat_cols&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_cols</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">target_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">target_cols</span><span class="p">]</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">target_cols</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="s2">&quot;target_cols should be str or list&quot;</span><span class="p">)</span>
        <span class="n">check_col_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">target_cols</span><span class="p">)</span>
        <span class="n">nonnumeric_target_col_type</span> <span class="o">=</span> <span class="n">get_nonnumeric_col_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">target_cols</span><span class="p">)</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="ow">not</span> <span class="n">nonnumeric_target_col_type</span><span class="p">,</span>
                          <span class="s2">&quot;target_cols should be numeric but get &quot;</span> <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                              <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot; of type &quot;</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                                       <span class="n">nonnumeric_target_col_type</span><span class="p">))))</span>

        <span class="k">if</span> <span class="n">out_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out_cols</span> <span class="o">=</span> <span class="p">[[</span><span class="n">gen_cols_name</span><span class="p">(</span><span class="n">cat_col</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;_te_&quot;</span> <span class="o">+</span> <span class="n">target_col</span>
                         <span class="k">for</span> <span class="n">target_col</span> <span class="ow">in</span> <span class="n">target_cols</span><span class="p">]</span> <span class="k">for</span> <span class="n">cat_col</span> <span class="ow">in</span> <span class="n">cat_cols</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_cols</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cat_cols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_cols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
                                  <span class="s2">&quot;out_cols can be string only if both cat_cols and&quot;</span>
                                  <span class="s2">&quot; target_cols has only one element&quot;</span><span class="p">)</span>
                <span class="n">out_cols</span> <span class="o">=</span> <span class="p">[[</span><span class="n">out_cols</span><span class="p">]]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_cols</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">out_col</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">out_col</span> <span class="ow">in</span> <span class="n">out_cols</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cat_cols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">out_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">out_cols</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_cols</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">out_cols</span> <span class="o">=</span> <span class="p">[[</span><span class="n">out_col</span><span class="p">]</span> <span class="k">for</span> <span class="n">out_col</span> <span class="ow">in</span> <span class="n">out_cols</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="s2">&quot;out_cols should be a nested list of str when both &quot;</span> <span class="o">+</span>
                                          <span class="s2">&quot;cat_cols and target_cols have more than one elements&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">outs</span> <span class="ow">in</span> <span class="n">out_cols</span><span class="p">:</span>
                        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span>
                                          <span class="s2">&quot;out_cols should be str, a list of str,&quot;</span>
                                          <span class="s2">&quot; or a nested list of str&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="s2">&quot;out_cols should be str, a list of str, or a nested list of str&quot;</span><span class="p">)</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">out_cols</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">cat_cols</span><span class="p">),</span>
                              <span class="s2">&quot;length of out_cols should be equal to length of cat_cols&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">outs</span> <span class="ow">in</span> <span class="n">out_cols</span><span class="p">:</span>
                <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">target_cols</span><span class="p">),</span>
                                  <span class="s2">&quot;length of element in out_cols should&quot;</span>
                                  <span class="s2">&quot; be equal to length of target_cols&quot;</span><span class="p">)</span>

        <span class="c1"># calculate global mean for each target column</span>
        <span class="n">target_mean_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">target_mean</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">target_mean</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;target_mean should be a dict&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">target_col</span> <span class="ow">in</span> <span class="n">target_cols</span><span class="p">:</span>
                <span class="n">invalidInputError</span><span class="p">(</span><span class="n">target_col</span> <span class="ow">in</span> <span class="n">target_mean</span><span class="p">,</span>
                                  <span class="s2">&quot;target column &quot;</span> <span class="o">+</span> <span class="n">target_col</span> <span class="o">+</span> <span class="s2">&quot; should be in target_mean&quot;</span>
                                                                  <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">target_mean</span><span class="p">))</span>
                <span class="n">target_mean_dict</span><span class="p">[</span><span class="n">target_col</span><span class="p">]</span> <span class="o">=</span> <span class="n">target_mean</span><span class="p">[</span><span class="n">target_col</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">global_mean_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">F</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">pyspark_col</span><span class="p">(</span><span class="n">target_col</span><span class="p">))</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">target_col</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">target_col</span> <span class="ow">in</span> <span class="n">target_cols</span><span class="p">]</span>
            <span class="n">target_mean_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">*</span><span class="n">global_mean_list</span><span class="p">)</span><span class="o">.</span><span class="n">collect</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">asDict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">target_col</span> <span class="ow">in</span> <span class="n">target_mean_dict</span><span class="p">:</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="n">target_mean_dict</span><span class="p">[</span><span class="n">target_col</span><span class="p">]</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="s2">&quot;mean of target column </span><span class="si">{}</span><span class="s2"> should not be None&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">target_col</span><span class="p">))</span>

        <span class="c1"># generate fold_col</span>
        <span class="n">result_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>
        <span class="k">if</span> <span class="n">kfold</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fold_col</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">fold_seed</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">result_df</span> <span class="o">=</span> <span class="n">result_df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                        <span class="n">fold_col</span><span class="p">,</span>
                        <span class="n">monotonically_increasing_id</span><span class="p">()</span> <span class="o">%</span> <span class="n">lit</span><span class="p">(</span><span class="n">kfold</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">result_df</span> <span class="o">=</span> <span class="n">result_df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                        <span class="n">fold_col</span><span class="p">,</span> <span class="p">(</span><span class="n">F</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">fold_seed</span><span class="p">)</span> <span class="o">*</span> <span class="n">kfold</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">IntegerType</span><span class="p">()))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">invalidInputError</span><span class="p">(</span>
                    <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">fold_col</span> <span class="ow">and</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">dtypes</span><span class="p">)),</span>
                    <span class="s2">&quot;fold_col should be integer type but get &quot;</span> <span class="o">+</span> <span class="n">fold_col</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fold_col</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">def</span> <span class="nf">gen_target_code</span><span class="p">(</span><span class="n">cat_out</span><span class="p">):</span>
            <span class="n">cat_col</span> <span class="o">=</span> <span class="n">cat_out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">out_col_list</span> <span class="o">=</span> <span class="n">cat_out</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">cat_col_name</span> <span class="o">=</span> <span class="n">gen_cols_name</span><span class="p">(</span><span class="n">cat_col</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>

            <span class="n">sum_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">F</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">target_col</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">cat_col_name</span> <span class="o">+</span> <span class="s2">&quot;_all_sum_&quot;</span> <span class="o">+</span> <span class="n">target_col</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">target_col</span> <span class="ow">in</span> <span class="n">target_cols</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cat_col</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">org_all_df</span> <span class="o">=</span> <span class="n">result_df</span><span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="n">cat_col</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">org_all_df</span> <span class="o">=</span> <span class="n">result_df</span><span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="o">*</span><span class="n">cat_col</span><span class="p">)</span>
            <span class="n">org_all_df</span> <span class="o">=</span> <span class="n">org_all_df</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="o">*</span><span class="n">sum_list</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">cat_col_name</span> <span class="o">+</span> <span class="s2">&quot;_all_count&quot;</span><span class="p">))</span>
            <span class="n">all_df</span> <span class="o">=</span> <span class="n">org_all_df</span>
            <span class="k">for</span> <span class="n">target_col</span><span class="p">,</span> <span class="n">out_col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">target_cols</span><span class="p">,</span> <span class="n">out_col_list</span><span class="p">):</span>
                <span class="n">global_target_mean</span> <span class="o">=</span> <span class="n">target_mean_dict</span><span class="p">[</span><span class="n">target_col</span><span class="p">]</span>
                <span class="n">all_func</span> <span class="o">=</span> <span class="n">udf</span><span class="p">(</span>
                    <span class="k">lambda</span> <span class="n">cat_sum</span><span class="p">,</span> <span class="n">cat_count</span><span class="p">:</span>
                    <span class="p">(</span><span class="n">cat_sum</span> <span class="o">+</span> <span class="n">global_target_mean</span> <span class="o">*</span> <span class="n">smooth</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">cat_count</span> <span class="o">+</span> <span class="n">smooth</span><span class="p">),</span>
                    <span class="n">DoubleType</span><span class="p">())</span>
                <span class="n">all_df</span> <span class="o">=</span> <span class="n">all_df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">out_col</span><span class="p">,</span>
                                           <span class="n">all_func</span><span class="p">(</span><span class="n">cat_col_name</span> <span class="o">+</span> <span class="s2">&quot;_all_sum_&quot;</span> <span class="o">+</span> <span class="n">target_col</span><span class="p">,</span>
                                                    <span class="n">cat_col_name</span> <span class="o">+</span> <span class="s2">&quot;_all_count&quot;</span><span class="p">))</span> \
                    <span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">cat_col_name</span> <span class="o">+</span> <span class="s2">&quot;_all_sum_&quot;</span> <span class="o">+</span> <span class="n">target_col</span><span class="p">)</span>
            <span class="c1"># keep count in the target code</span>
            <span class="n">all_df</span> <span class="o">=</span> <span class="n">all_df</span><span class="o">.</span><span class="n">withColumnRenamed</span><span class="p">(</span><span class="n">cat_col_name</span> <span class="o">+</span> <span class="s2">&quot;_all_count&quot;</span><span class="p">,</span> <span class="s2">&quot;target_encode_count&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">kfold</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">fold_df</span> <span class="o">=</span> <span class="n">all_df</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fold_sum_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">F</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">target_col</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">cat_col_name</span> <span class="o">+</span> <span class="s2">&quot;_sum_&quot;</span> <span class="o">+</span> <span class="n">target_col</span><span class="p">)</span>
                                 <span class="k">for</span> <span class="n">target_col</span> <span class="ow">in</span> <span class="n">target_cols</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cat_col</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                    <span class="n">fold_df</span> <span class="o">=</span> <span class="n">result_df</span><span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="n">cat_col</span><span class="p">,</span> <span class="n">fold_col</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fold_df</span> <span class="o">=</span> <span class="n">result_df</span><span class="o">.</span><span class="n">groupBy</span><span class="p">(</span><span class="o">*</span><span class="n">cat_col</span><span class="p">,</span> <span class="n">fold_col</span><span class="p">)</span>
                <span class="n">fold_df</span> <span class="o">=</span> <span class="n">fold_df</span><span class="o">.</span><span class="n">agg</span><span class="p">(</span><span class="o">*</span><span class="n">fold_sum_list</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s2">&quot;*&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">alias</span><span class="p">(</span><span class="n">cat_col_name</span> <span class="o">+</span> <span class="s2">&quot;_count&quot;</span><span class="p">))</span>
                <span class="n">fold_df</span> <span class="o">=</span> <span class="n">fold_df</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">org_all_df</span><span class="p">,</span> <span class="n">cat_col</span><span class="p">,</span> <span class="n">how</span><span class="o">=</span><span class="s2">&quot;left&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">target_col</span><span class="p">,</span> <span class="n">out_col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">target_cols</span><span class="p">,</span> <span class="n">out_col_list</span><span class="p">):</span>
                    <span class="n">global_target_mean</span> <span class="o">=</span> <span class="n">target_mean_dict</span><span class="p">[</span><span class="n">target_col</span><span class="p">]</span>
                    <span class="n">target_func</span> <span class="o">=</span> <span class="n">udf</span><span class="p">(</span>
                        <span class="k">lambda</span> <span class="n">s_all</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">c_all</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span>
                        <span class="kc">None</span> <span class="k">if</span> <span class="n">c_all</span> <span class="o">==</span> <span class="n">c</span> <span class="k">else</span>
                        <span class="p">((</span><span class="n">s_all</span> <span class="o">-</span> <span class="n">s</span><span class="p">)</span> <span class="o">+</span> <span class="n">global_target_mean</span> <span class="o">*</span> <span class="n">smooth</span><span class="p">)</span> <span class="o">/</span> <span class="p">((</span><span class="n">c_all</span> <span class="o">-</span> <span class="n">c</span><span class="p">)</span> <span class="o">+</span> <span class="n">smooth</span><span class="p">),</span>
                        <span class="n">DoubleType</span><span class="p">())</span>
                    <span class="n">fold_df</span> <span class="o">=</span> <span class="n">fold_df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span>
                        <span class="n">out_col</span><span class="p">,</span>
                        <span class="n">target_func</span><span class="p">(</span><span class="n">cat_col_name</span> <span class="o">+</span> <span class="s2">&quot;_all_sum_&quot;</span> <span class="o">+</span> <span class="n">target_col</span><span class="p">,</span>
                                    <span class="n">cat_col_name</span> <span class="o">+</span> <span class="s2">&quot;_sum_&quot;</span> <span class="o">+</span> <span class="n">target_col</span><span class="p">,</span>
                                    <span class="n">cat_col_name</span> <span class="o">+</span> <span class="s2">&quot;_all_count&quot;</span><span class="p">,</span>
                                    <span class="n">cat_col_name</span> <span class="o">+</span> <span class="s2">&quot;_count&quot;</span><span class="p">)</span>
                    <span class="p">)</span>
                    <span class="n">fold_df</span> <span class="o">=</span> <span class="n">fold_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">cat_col_name</span> <span class="o">+</span> <span class="s2">&quot;_sum_&quot;</span> <span class="o">+</span> <span class="n">target_col</span><span class="p">,</span>
                                           <span class="n">cat_col_name</span> <span class="o">+</span> <span class="s2">&quot;_all_sum_&quot;</span> <span class="o">+</span> <span class="n">target_col</span><span class="p">)</span>
                <span class="n">fold_df</span> <span class="o">=</span> <span class="n">fold_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">cat_col_name</span> <span class="o">+</span> <span class="s2">&quot;_count&quot;</span><span class="p">)</span> \
                    <span class="o">.</span><span class="n">withColumnRenamed</span><span class="p">(</span><span class="n">cat_col_name</span> <span class="o">+</span> <span class="s2">&quot;_all_count&quot;</span><span class="p">,</span> <span class="s2">&quot;target_encode_count&quot;</span><span class="p">)</span>

            <span class="n">out_target_mean_dict</span> <span class="o">=</span> <span class="p">{</span>
                <span class="n">out_col</span><span class="p">:</span> <span class="p">(</span><span class="n">target_col</span><span class="p">,</span> <span class="n">target_mean_dict</span><span class="p">[</span><span class="n">target_col</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">target_col</span><span class="p">,</span> <span class="n">out_col</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">target_cols</span><span class="p">,</span> <span class="n">out_col_list</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">TargetCode</span><span class="p">(</span><span class="n">fold_df</span><span class="p">,</span> <span class="n">cat_col</span><span class="p">,</span> <span class="n">out_target_mean_dict</span><span class="p">),</span> \
                <span class="n">TargetCode</span><span class="p">(</span><span class="n">all_df</span><span class="p">,</span> <span class="n">cat_col</span><span class="p">,</span> <span class="n">out_target_mean_dict</span><span class="p">)</span>

        <span class="n">targets</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">gen_target_code</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="n">cat_cols</span><span class="p">,</span> <span class="n">out_cols</span><span class="p">)))</span>

        <span class="n">fold_targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">]</span>
        <span class="n">all_targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">]</span>

        <span class="n">result_tbl</span> <span class="o">=</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">result_df</span><span class="p">)</span>
        <span class="n">result_tbl</span> <span class="o">=</span> <span class="n">encode_target_</span><span class="p">(</span><span class="n">result_tbl</span><span class="p">,</span> <span class="n">fold_targets</span><span class="p">,</span> <span class="n">drop_cat</span><span class="o">=</span><span class="n">drop_cat</span><span class="p">,</span>
                                    <span class="n">drop_fold</span><span class="o">=</span><span class="n">drop_fold</span><span class="p">,</span> <span class="n">fold_col</span><span class="o">=</span><span class="n">fold_col</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result_tbl</span><span class="p">,</span> <span class="n">all_targets</span></div>

<div class="viewcode-block" id="FeatureTable.encode_target"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.encode_target">[docs]</a>    <span class="k">def</span> <span class="nf">encode_target</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span> <span class="n">target_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">drop_cat</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Encode columns with the provided TargetCode(s).</span>

<span class="sd">        :param targets: TargetCode or a list of TargetCode.</span>
<span class="sd">        :param target_cols: str or a list of str. Selects part of target columns of which target</span>
<span class="sd">               encoding will be applied. Default is None and in this case all target columns</span>
<span class="sd">               contained in targets will be encoded.</span>
<span class="sd">        :param drop_cat: boolean, whether to drop the categorical column(s). Default is True.</span>

<span class="sd">        :return: A new FeatureTable which encodes each categorical column into group-specific</span>
<span class="sd">                 mean of target columns with provided TargetCodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="n">TargetCode</span><span class="p">):</span>
            <span class="n">targets</span> <span class="o">=</span> <span class="p">[</span><span class="n">targets</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">targets</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">target_code</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
                <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">target_code</span><span class="p">,</span> <span class="n">TargetCode</span><span class="p">),</span>
                                  <span class="s2">&quot;element in targets should be TargetCode&quot;</span>
                                  <span class="s2">&quot; but get </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">target_code</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                              <span class="s2">&quot;targets should be TargetCode or list of TargetCode&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">target_code</span> <span class="ow">in</span> <span class="n">targets</span><span class="p">:</span>
            <span class="n">check_col_str_list_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">target_code</span><span class="o">.</span><span class="n">cat_col</span><span class="p">,</span>
                                      <span class="s2">&quot;TargetCode.cat_col in targets&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">target_cols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">target_cols</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">target_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">target_cols</span><span class="p">]</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">target_cols</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span> <span class="s2">&quot;target_cols should be str or list&quot;</span><span class="p">)</span>

        <span class="n">result_tbl</span> <span class="o">=</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">)</span>
        <span class="n">result_tbl</span> <span class="o">=</span> <span class="n">encode_target_</span><span class="p">(</span><span class="n">result_tbl</span><span class="p">,</span> <span class="n">targets</span><span class="p">,</span> <span class="n">target_cols</span><span class="o">=</span><span class="n">target_cols</span><span class="p">,</span>
                                    <span class="n">drop_cat</span><span class="o">=</span><span class="n">drop_cat</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">result_tbl</span></div>

<div class="viewcode-block" id="FeatureTable.difference_lag"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.difference_lag">[docs]</a>    <span class="k">def</span> <span class="nf">difference_lag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">sort_cols</span><span class="p">,</span> <span class="n">shifts</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">partition_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the difference between two consecutive rows, or two rows with certain interval</span>
<span class="sd">        of the specified continuous columns. The table is first partitioned by partition_cols if it</span>
<span class="sd">        is not None, and then sorted by sort_cols before the calculation.</span>

<span class="sd">        :param columns: str or a list of str. Continuous columns to calculate the difference.</span>
<span class="sd">        :param sort_cols: str or a list of str. Columns by which the table is sorted.</span>
<span class="sd">        :param shifts: int or a list of int. Intervals between two rows.</span>
<span class="sd">        :param partition_cols: Columns by which the table is partitioned.</span>
<span class="sd">        :param out_cols: str, a list of str, or a nested list of str. When both columns and shifts</span>
<span class="sd">               has only one element, out_cols can be a single str. When columns or shifts has only</span>
<span class="sd">               one element, out_cols can be a list of str, and each element in out_cols corresponds</span>
<span class="sd">               to an element in shifts or columns. When it is a list of list of str, each inner list</span>
<span class="sd">               corresponds to a column in columns. Each element in the inner list corresponds to a</span>
<span class="sd">               shift in shifts. If it is None, the output column will be sort_cols + &quot;_diff_lag_&quot;</span>
<span class="sd">               + column + &quot;_&quot; + shift. Default is None.</span>

<span class="sd">        :return: A new FeatureTable with difference columns.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">str_to_list</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">)</span>
        <span class="n">sort_cols</span> <span class="o">=</span> <span class="n">str_to_list</span><span class="p">(</span><span class="n">sort_cols</span><span class="p">,</span> <span class="s2">&quot;sort_cols&quot;</span><span class="p">)</span>
        <span class="n">nonnumeric_col_type</span> <span class="o">=</span> <span class="n">get_nonnumeric_col_type</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;columns should be numeric but get &quot;</span> <span class="o">+</span> \
              <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="s2">&quot; of type &quot;</span> <span class="o">+</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nonnumeric_col_type</span><span class="p">)))</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="ow">not</span> <span class="n">nonnumeric_col_type</span><span class="p">,</span> <span class="n">msg</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shifts</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">shifts</span> <span class="o">=</span> <span class="p">[</span><span class="n">shifts</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shifts</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">:</span>
                <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
                                  <span class="s2">&quot;elements in shift should be integer but get &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                              <span class="s2">&quot;shift should be either int or a list of int&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">partition_cols</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">partition_cols</span> <span class="o">=</span> <span class="n">str_to_list</span><span class="p">(</span><span class="n">partition_cols</span><span class="p">,</span> <span class="s2">&quot;partition_cols&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sort_name</span> <span class="o">=</span> <span class="n">gen_cols_name</span><span class="p">(</span><span class="n">sort_cols</span><span class="p">)</span>
            <span class="n">out_cols</span> <span class="o">=</span> <span class="p">[[</span><span class="n">sort_name</span> <span class="o">+</span> <span class="s2">&quot;_diff_lag_&quot;</span> <span class="o">+</span> <span class="n">column</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">shift</span><span class="p">)</span>
                         <span class="k">for</span> <span class="n">shift</span> <span class="ow">in</span> <span class="n">shifts</span><span class="p">]</span> <span class="k">for</span> <span class="n">column</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_cols</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">shifts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
                                  <span class="s2">&quot;out_cols can be string only if both columns&quot;</span>
                                  <span class="s2">&quot; and shifts has only one element&quot;</span><span class="p">)</span>
                <span class="n">out_cols</span> <span class="o">=</span> <span class="p">[[</span><span class="n">out_cols</span><span class="p">]]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">out_cols</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">out_col</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="k">for</span> <span class="n">out_col</span> <span class="ow">in</span> <span class="n">out_cols</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">out_cols</span> <span class="o">=</span> <span class="p">[</span><span class="n">out_cols</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">shifts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">out_cols</span> <span class="o">=</span> <span class="p">[[</span><span class="n">out_col</span><span class="p">]</span> <span class="k">for</span> <span class="n">out_col</span> <span class="ow">in</span> <span class="n">out_cols</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                                          <span class="s2">&quot;out_cols should be a list of list of str when both &quot;</span> <span class="o">+</span>
                                          <span class="s2">&quot;columns shifts have more than one elements&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">outs</span> <span class="ow">in</span> <span class="n">out_cols</span><span class="p">:</span>
                        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">outs</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span>
                                          <span class="s2">&quot;out_cols should be str, a list of str,&quot;</span>
                                          <span class="s2">&quot; or a list of lists of str&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="s2">&quot;out_cols should be str, a list of str, or a list&quot;</span>
                                  <span class="s2">&quot; of lists of str&quot;</span><span class="p">)</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">out_cols</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">),</span>
                              <span class="s2">&quot;length of out_cols should be equal to length of columns&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">outs</span> <span class="ow">in</span> <span class="n">out_cols</span><span class="p">:</span>
                <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">outs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">shifts</span><span class="p">),</span>
                                  <span class="s2">&quot;length of element in out_cols should be equal&quot;</span>
                                  <span class="s2">&quot; to length of shifts&quot;</span><span class="p">)</span>

        <span class="n">result_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>
        <span class="k">if</span> <span class="n">partition_cols</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">partition_window</span> <span class="o">=</span> <span class="n">Window</span><span class="o">.</span><span class="n">orderBy</span><span class="p">(</span><span class="o">*</span><span class="n">sort_cols</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">partition_window</span> <span class="o">=</span> <span class="n">Window</span><span class="o">.</span><span class="n">partitionBy</span><span class="p">(</span><span class="o">*</span><span class="n">partition_cols</span><span class="p">)</span><span class="o">.</span><span class="n">orderBy</span><span class="p">(</span><span class="o">*</span><span class="n">sort_cols</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">column</span><span class="p">,</span> <span class="n">outs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">out_cols</span><span class="p">):</span>
            <span class="n">diff_func</span> <span class="o">=</span> <span class="n">udf</span><span class="p">(</span><span class="k">lambda</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="k">if</span> <span class="n">a</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">b</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">schema</span><span class="p">[</span><span class="n">column</span><span class="p">]</span><span class="o">.</span><span class="n">dataType</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">shift</span><span class="p">,</span> <span class="n">out</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">shifts</span><span class="p">,</span> <span class="n">outs</span><span class="p">):</span>
                <span class="n">result_df</span> <span class="o">=</span> <span class="n">result_df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">F</span><span class="o">.</span><span class="n">lag</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">shift</span><span class="p">)</span><span class="o">.</span><span class="n">over</span><span class="p">(</span><span class="n">partition_window</span><span class="p">))</span>
                <span class="n">result_df</span> <span class="o">=</span> <span class="n">result_df</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">diff_func</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="n">out</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">result_df</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatureTable.cut_bins"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.cut_bins">[docs]</a>    <span class="k">def</span> <span class="nf">cut_bins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">bins</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_cols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Segment values of the target column(s) into bins, which is also known as bucketization.</span>

<span class="sd">        :param columns: str or a list of str, the numeric column(s) to segment into intervals.</span>
<span class="sd">        :param bins: int, a list of int or dict.</span>
<span class="sd">               If bins is a list, it defines the bins to be used. **NOTE** that for bins of</span>
<span class="sd">               length n, there will be **n+1** buckets.</span>
<span class="sd">               For example, if bins is [0, 6, 18, 60], the resulting buckets are</span>
<span class="sd">               (-inf, 0), [0, 6), [6, 18), [18, 60), [60, inf).</span>
<span class="sd">               If bins is an int, it defines the number of equal-width bins in the range of all</span>
<span class="sd">               the column values, i.e. from column min to max. **NOTE** that there will be</span>
<span class="sd">               **bins+2** resulting buckets in total to take the values below min and beyond max</span>
<span class="sd">               into consideration.</span>
<span class="sd">               For examples, if bins is 2, the resulting buckets are</span>
<span class="sd">               (-inf, col_min), [col_min, (col_min+col_max)/2), [(col_min+col_max)/2, col_max),</span>
<span class="sd">               [col_max, inf).</span>
<span class="sd">               If bins is a dict, the key should be the input column(s) and the value should be</span>
<span class="sd">               int or a list of int to specify the bins as described above.</span>
<span class="sd">        :param labels: a list of str or dict, the labels for the returned bins.</span>
<span class="sd">               Default is None, and in this case the new bin column would use the integer index to</span>
<span class="sd">               encode the interval. Index would start from 0.</span>
<span class="sd">               If labels is a list of str, then the corresponding label would be used to replace</span>
<span class="sd">               the integer index at the same position. The number of elements in labels should be</span>
<span class="sd">               the same as the number of bins.</span>
<span class="sd">               If labels is a dict, the key should be the input column(s) and the value should be a</span>
<span class="sd">               list of str as described above.</span>
<span class="sd">        :param out_cols: str or a list of str, the name of output bucketized column(s).</span>
<span class="sd">               Default is None, and in this case the name of each output column will be &quot;column_bin&quot;</span>
<span class="sd">               for each input column.</span>
<span class="sd">        :param drop: boolean, whether to drop the original column(s). Default is True.</span>

<span class="sd">        :return: A new FeatureTable with feature bucket column(s).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">str_to_list</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out_cols</span><span class="p">:</span>
            <span class="n">out_cols</span> <span class="o">=</span> <span class="n">str_to_list</span><span class="p">(</span><span class="n">out_cols</span><span class="p">,</span> <span class="s2">&quot;out_cols&quot;</span><span class="p">)</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">out_cols</span><span class="p">),</span>
                              <span class="s2">&quot;columns and out_cols should have the same length&quot;</span><span class="p">)</span>
        <span class="n">check_col_exists</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">columns</span><span class="p">)</span>
        <span class="n">df_buck</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">columns</span><span class="p">)):</span>
            <span class="n">column</span> <span class="o">=</span> <span class="n">columns</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">temp_out_col</span> <span class="o">=</span> <span class="n">column</span> <span class="o">+</span> <span class="s2">&quot;_bin&quot;</span>
            <span class="nb">bin</span> <span class="o">=</span> <span class="n">bins</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bins</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="n">bins</span>
            <span class="n">label</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="n">column</span><span class="p">]</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">else</span> <span class="n">labels</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">check_column_numeric</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">column</span><span class="p">):</span>
                <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> should be a numeric column&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">column</span><span class="p">))</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">bin</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">col_max</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stats</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="s2">&quot;max&quot;</span><span class="p">)[</span><span class="n">column</span><span class="p">]</span>
                <span class="n">col_min</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stats</span><span class="p">(</span><span class="n">column</span><span class="p">,</span> <span class="s2">&quot;min&quot;</span><span class="p">)[</span><span class="n">column</span><span class="p">]</span>
                <span class="nb">bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">col_min</span><span class="p">,</span> <span class="n">col_max</span><span class="p">,</span> <span class="nb">bin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">bin</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                                  <span class="s2">&quot;bins should int, a list of int or dict with column name &quot;</span>
                                  <span class="s2">&quot;as the key and int or a list of int as the value&quot;</span><span class="p">)</span>
            <span class="nb">bin</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;-inf&quot;</span><span class="p">)]</span> <span class="o">+</span> <span class="nb">bin</span> <span class="o">+</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)]</span>
            <span class="c1"># For Bucketizer, inputCol and outputCol must be different.</span>
            <span class="n">bucketizer</span> <span class="o">=</span> <span class="n">Bucketizer</span><span class="p">(</span><span class="n">splits</span><span class="o">=</span><span class="nb">bin</span><span class="p">,</span> <span class="n">inputCol</span><span class="o">=</span><span class="n">column</span><span class="p">,</span> <span class="n">outputCol</span><span class="o">=</span><span class="n">temp_out_col</span><span class="p">)</span>
            <span class="n">df_buck</span> <span class="o">=</span> <span class="n">bucketizer</span><span class="o">.</span><span class="n">setHandleInvalid</span><span class="p">(</span><span class="s2">&quot;keep&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">df_buck</span><span class="p">)</span>
            <span class="c1"># The output of Buckerizer is float, cast to int.</span>
            <span class="n">df_buck</span> <span class="o">=</span> <span class="n">df_buck</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">temp_out_col</span><span class="p">,</span> <span class="n">pyspark_col</span><span class="p">(</span><span class="n">temp_out_col</span><span class="p">)</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="s2">&quot;int&quot;</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">label</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="nb">list</span><span class="p">),</span>
                                  <span class="s2">&quot;labels should be a list of str or a dict with column name as&quot;</span>
                                  <span class="s2">&quot; the key and a list of str as the value&quot;</span><span class="p">)</span>
                <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">label</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">bin</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                                  <span class="s2">&quot;labels should be of length </span><span class="si">{}</span><span class="s2"> to match&quot;</span>
                                  <span class="s2">&quot; bins&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="nb">bin</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="n">to_label</span> <span class="o">=</span> <span class="p">{</span><span class="n">i</span><span class="p">:</span> <span class="n">l</span> <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">label</span><span class="p">)}</span>
                <span class="n">udf_label</span> <span class="o">=</span> <span class="n">udf</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">to_label</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">StringType</span><span class="p">())</span>
                <span class="n">df_buck</span> <span class="o">=</span> <span class="n">df_buck</span><span class="o">.</span><span class="n">withColumn</span><span class="p">(</span><span class="n">temp_out_col</span><span class="p">,</span> <span class="n">udf_label</span><span class="p">(</span><span class="n">temp_out_col</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">out_cols</span><span class="p">:</span>
                <span class="n">out_col</span> <span class="o">=</span> <span class="n">out_cols</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">out_col</span> <span class="o">==</span> <span class="n">column</span> <span class="ow">or</span> <span class="n">drop</span><span class="p">:</span>  <span class="c1"># Replace the input column with the output column</span>
                    <span class="n">df_buck</span> <span class="o">=</span> <span class="n">df_buck</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">column</span><span class="p">)</span><span class="o">.</span><span class="n">withColumnRenamed</span><span class="p">(</span><span class="n">temp_out_col</span><span class="p">,</span> <span class="n">out_col</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">df_buck</span> <span class="o">=</span> <span class="n">df_buck</span><span class="o">.</span><span class="n">withColumnRenamed</span><span class="p">(</span><span class="n">temp_out_col</span><span class="p">,</span> <span class="n">out_col</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">drop</span><span class="p">:</span>
                    <span class="n">df_buck</span> <span class="o">=</span> <span class="n">df_buck</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">column</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_clone</span><span class="p">(</span><span class="n">df_buck</span><span class="p">)</span></div>

<div class="viewcode-block" id="FeatureTable.get_vocabularies"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.get_vocabularies">[docs]</a>    <span class="k">def</span> <span class="nf">get_vocabularies</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create vocabulary for each column, and return dict of vocabularies</span>

<span class="sd">        :param columns: str or a list of str. Columns to generate vocabularies.</span>

<span class="sd">        :return: A dict of vocabularies.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">columns</span> <span class="o">=</span> <span class="n">str_to_list</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;columns&quot;</span><span class="p">)</span>
        <span class="n">vocabularies</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">columns</span><span class="p">:</span>
            <span class="n">vocabularies</span><span class="p">[</span><span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> \
                <span class="o">.</span><span class="n">distinct</span><span class="p">()</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">row</span><span class="p">:</span> <span class="n">row</span><span class="p">[</span><span class="n">col</span><span class="p">])</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">vocabularies</span></div>

<div class="viewcode-block" id="FeatureTable.sample_listwise"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.FeatureTable.sample_listwise">[docs]</a>    <span class="k">def</span> <span class="nf">sample_listwise</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">num_sampled_list</span><span class="p">,</span> <span class="n">num_sampled_item</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">replace</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the FeatureTable to a sample listwise FeatureTable. The columns should be of list</span>
<span class="sd">        type and have the same length. Note that the rows with list length &lt; num_sampled_item will</span>
<span class="sd">        be dropped since they don&#39;t have enough examples.</span>

<span class="sd">        You can use groupby to aggregate records under the same key before calling sample_listwise.</span>
<span class="sd">        &gt;&gt;&gt; tbl</span>
<span class="sd">        +----+----+----+</span>
<span class="sd">        |name|   a|   b|</span>
<span class="sd">        +----+----+----+</span>
<span class="sd">        |   a|   1|   1|</span>
<span class="sd">        |   a|   2|   2|</span>
<span class="sd">        |   b|   1|   1|</span>
<span class="sd">        +----+----+----+</span>
<span class="sd">        &gt;&gt;&gt; tbl.group_by(&quot;name&quot;, agg=&quot;collect_list&quot;)</span>
<span class="sd">        +----+------------------+------------------+</span>
<span class="sd">        |name|   collect_list(a)|   collect_list(b)|</span>
<span class="sd">        +----+------------------+------------------+</span>
<span class="sd">        |   a|            [1, 2]|            [1, 2]|</span>
<span class="sd">        |   b|               [1]|               [1]|</span>
<span class="sd">        +----+------------------+------------------+</span>
<span class="sd">        &gt;&gt;&gt; tbl</span>
<span class="sd">        +----+------------+------------+--------------------+</span>
<span class="sd">        |name|     int_arr|     str_arr|         int_arr_arr|</span>
<span class="sd">        +----+------------+------------+--------------------+</span>
<span class="sd">        |   a|   [1, 2, 3]|   [1, 2, 3]|     [[1], [2], [3]]|</span>
<span class="sd">        |   b|[1, 2, 3, 4]|[1, 2, 3, 4]|[[1], [2], [3], [4]]|</span>
<span class="sd">        |   c|         [1]|         [1]|               [[1]]|</span>
<span class="sd">        +----+------------+------------+--------------------+</span>
<span class="sd">        &gt;&gt;&gt; tbl.sample_listwise([&quot;int_arr&quot;, &quot;str_arr&quot;, &quot;int_arr_arr&quot;], num_sampled_list=4,</span>
<span class="sd">        &gt;&gt;&gt;                     num_sampled_item=2)</span>
<span class="sd">        +----+-------+-------+-----------+</span>
<span class="sd">        |name|int_arr|str_arr|int_arr_arr|</span>
<span class="sd">        +----+-------+-------+-----------+</span>
<span class="sd">        |   a| [1, 3]| [1, 3]| [[1], [3]]|</span>
<span class="sd">        |   a| [2, 1]| [2, 1]| [[2], [1]]|</span>
<span class="sd">        |   a| [3, 2]| [3, 2]| [[3], [2]]|</span>
<span class="sd">        |   a| [2, 3]| [2, 3]| [[2], [3]]|</span>
<span class="sd">        |   b| [4, 1]| [4, 1]| [[4], [1]]|</span>
<span class="sd">        |   b| [2, 3]| [2, 3]| [[2], [3]]|</span>
<span class="sd">        |   b| [2, 3]| [2, 3]| [[2], [3]]|</span>
<span class="sd">        |   b| [2, 3]| [2, 3]| [[2], [3]]|</span>
<span class="sd">        +----+-------+-------+-----------+</span>
<span class="sd">        &gt;&gt;&gt; tbl.sample_listwise([&quot;int_arr&quot;, &quot;str_arr&quot;], num_sampled_list=2,</span>
<span class="sd">        &gt;&gt;&gt;                     num_sampled_item=2, replace=False)</span>
<span class="sd">        +----+------------+------------+--------------------+---------------+---------------+</span>
<span class="sd">        |name|     int_arr|     str_arr|         int_arr_arr|sampled_int_arr|sampled_str_arr|</span>
<span class="sd">        +----+------------+------------+--------------------+---------------+---------------+</span>
<span class="sd">        |   a|   [1, 2, 3]|   [1, 2, 3]|     [[1], [2], [3]]|         [3, 2]|         [3, 2]|</span>
<span class="sd">        |   a|   [1, 2, 3]|   [1, 2, 3]|     [[1], [2], [3]]|         [2, 1]|         [2, 1]|</span>
<span class="sd">        |   b|[1, 2, 3, 4]|[1, 2, 3, 4]|[[1], [2], [3], [4]]|         [2, 4]|         [2, 4]|</span>
<span class="sd">        |   b|[1, 2, 3, 4]|[1, 2, 3, 4]|[[1], [2], [3], [4]]|         [4, 2]|         [4, 2]|</span>
<span class="sd">        +----+------------+------------+--------------------+---------------+---------------+</span>

<span class="sd">        :param columns: str or a list of str. Columns to convert to sampled list. Each column</span>
<span class="sd">               should be of list type. The list length of specified columns in the same row must</span>
<span class="sd">               be the same.</span>
<span class="sd">        :param num_sampled_list: int. The number of lists that should be sampled for each row.</span>
<span class="sd">        :param num_sampled_item: int. The number of elements to be sampled for each list from</span>
<span class="sd">               the list of each column.</span>
<span class="sd">        :param random_seed: int. The number for creating &#39;np.random.RandomState&#39;. Default: None.</span>
<span class="sd">        :param replace: bool. Indicates whether to replace the original columns. If replace=False,</span>
<span class="sd">               a corresponding column &quot;sampled_col&quot; will be generated for each sampled column.</span>

<span class="sd">        :return: A new sampled listwise FeatureTable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">str_to_list</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;cols&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">,</span> <span class="s2">&quot;Column &#39;&quot;</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span>
                              <span class="s2">&quot;&#39; does not exist in this FeatureTable.&quot;</span><span class="p">)</span>
            <span class="n">c_type</span> <span class="o">=</span> <span class="n">schema</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="o">.</span><span class="n">dataType</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">c_type</span><span class="p">,</span> <span class="n">ArrayType</span><span class="p">),</span>
                              <span class="s2">&quot;Each column should be of list type, but the type of column &#39;&quot;</span> <span class="o">+</span> <span class="n">c</span> <span class="o">+</span>
                              <span class="s2">&quot;&#39; is &quot;</span> <span class="o">+</span> <span class="n">c_type</span><span class="o">.</span><span class="n">simpleString</span><span class="p">())</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">replace</span><span class="p">:</span>
                <span class="n">c_schema</span> <span class="o">=</span> <span class="n">StructField</span><span class="p">(</span><span class="s2">&quot;sampled_&quot;</span> <span class="o">+</span> <span class="n">c</span><span class="p">,</span> <span class="n">c_type</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
                <span class="n">schema</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">c_schema</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">sample_features</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">random_state</span><span class="p">):</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">asDict</span><span class="p">()</span>
            <span class="n">len_set</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">c</span><span class="p">])</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">])</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">len_set</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">,</span>
                              <span class="s2">&quot;Each row of the FeatureTable should &quot;</span>
                              <span class="s2">&quot;have the same array length in the specified cols.&quot;</span><span class="p">)</span>
            <span class="n">length</span> <span class="o">=</span> <span class="n">len_set</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">sampled_rows</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">if</span> <span class="n">length</span> <span class="o">&gt;=</span> <span class="n">num_sampled_item</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_sampled_list</span><span class="p">):</span>
                    <span class="n">new_row</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
                    <span class="n">sampled_indices</span> <span class="o">=</span> <span class="n">random_state</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">length</span><span class="p">),</span> <span class="n">size</span><span class="o">=</span><span class="n">num_sampled_item</span><span class="p">,</span>
                                                          <span class="n">replace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
                        <span class="n">sampled_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">new_row</span><span class="p">[</span><span class="n">c</span><span class="p">][</span><span class="n">idx</span><span class="p">]</span> <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">sampled_indices</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">replace</span><span class="p">:</span>
                            <span class="n">new_row</span><span class="p">[</span><span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">sampled_list</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">new_row</span><span class="p">[</span><span class="s2">&quot;sampled_&quot;</span> <span class="o">+</span> <span class="n">c</span><span class="p">]</span> <span class="o">=</span> <span class="n">sampled_list</span>
                    <span class="n">sampled_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_row</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">sampled_rows</span>

        <span class="n">random_state</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">RandomState</span><span class="p">(</span><span class="n">seed</span><span class="o">=</span><span class="n">random_seed</span><span class="p">)</span>
        <span class="n">spark</span> <span class="o">=</span> <span class="n">OrcaContext</span><span class="o">.</span><span class="n">get_spark_session</span><span class="p">()</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">createDataFrame</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">rdd</span><span class="o">.</span><span class="n">flatMap</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span>
                                                       <span class="n">sample_features</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">random_state</span><span class="p">)),</span> <span class="n">schema</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">FeatureTable</span><span class="p">(</span><span class="n">df</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="StringIndex"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.StringIndex">[docs]</a><span class="k">class</span> <span class="nc">StringIndex</span><span class="p">(</span><span class="n">Table</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">col_name</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">,</span>
                          <span class="s2">&quot;StringIndex should have &gt;= 2 columns: col_name, id and other columns&quot;</span><span class="p">)</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="s2">&quot;id&quot;</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">,</span> <span class="s2">&quot;id should be a column of the DataFrame&quot;</span><span class="p">)</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="n">col_name</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">,</span> <span class="n">col_name</span> <span class="o">+</span> <span class="s2">&quot; should be a column of the DataFrame&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">col_name</span> <span class="o">=</span> <span class="n">col_name</span>

<div class="viewcode-block" id="StringIndex.read_parquet"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.StringIndex.read_parquet">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">read_parquet</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">paths</span><span class="p">,</span> <span class="n">col_name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads Parquet files as a StringIndex.</span>

<span class="sd">        :param paths: str or a list of str, the path(s) to Parquet file(s).</span>
<span class="sd">        :param col_name: str. The column name of the corresponding categorical column. If</span>
<span class="sd">               col_name is None, the file name will be used as col_name.</span>

<span class="sd">        :return: A StringIndex.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">paths</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">col_name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">col_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">paths</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">Table</span><span class="o">.</span><span class="n">_read_parquet</span><span class="p">(</span><span class="n">paths</span><span class="p">),</span> <span class="n">col_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="StringIndex.from_dict"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.StringIndex.from_dict">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dict</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">col_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the StringIndex from a dict of indices.</span>

<span class="sd">        :param indices: dict, the key is the categorical column, and the value is the</span>
<span class="sd">               corresponding index. We assume that the key is a str and the value</span>
<span class="sd">               is a int.</span>
<span class="sd">        :param col_name: str. The column name of the categorical column.</span>

<span class="sd">        :return: A StringIndex.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">spark</span> <span class="o">=</span> <span class="n">OrcaContext</span><span class="o">.</span><span class="n">get_spark_session</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                              <span class="s1">&#39;indices should be dict, but get &#39;</span> <span class="o">+</span> <span class="n">indices</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">col_name</span><span class="p">:</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                              <span class="s1">&#39;col_name should be str, but get None&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">col_name</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">invalidInputError</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span>
                              <span class="s1">&#39;col_name should be str, but get &#39;</span> <span class="o">+</span> <span class="n">col_name</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">{</span><span class="n">col_name</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s1">&#39;id&#39;</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]},</span> <span class="n">indices</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="n">schema</span> <span class="o">=</span> <span class="n">StructType</span><span class="p">([</span><span class="n">StructField</span><span class="p">(</span><span class="n">col_name</span><span class="p">,</span> <span class="n">StringType</span><span class="p">(),</span> <span class="kc">False</span><span class="p">),</span>
                             <span class="n">StructField</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">,</span> <span class="n">IntegerType</span><span class="p">(),</span> <span class="kc">False</span><span class="p">)])</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">spark</span><span class="o">.</span><span class="n">createDataFrame</span><span class="p">((</span><span class="n">Row</span><span class="p">(</span><span class="o">**</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">indices</span><span class="p">),</span> <span class="n">schema</span><span class="o">=</span><span class="n">schema</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">col_name</span><span class="p">)</span></div>

<div class="viewcode-block" id="StringIndex.to_dict"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.StringIndex.to_dict">[docs]</a>    <span class="k">def</span> <span class="nf">to_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the StringIndex to a dict, with the categorical features as keys and indices</span>
<span class="sd">        as values.</span>
<span class="sd">        Note that you may only call this if the StringIndex is small.</span>

<span class="sd">        :return: A dict for the mapping from string to index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span>
        <span class="n">index_id</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">)</span>
        <span class="n">col_id</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">col_name</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="o">.</span><span class="n">collect</span><span class="p">()</span>
        <span class="n">res_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
            <span class="n">res_dict</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">col_id</span><span class="p">]]</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">index_id</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">res_dict</span></div>

<div class="viewcode-block" id="StringIndex.write_parquet"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.StringIndex.write_parquet">[docs]</a>    <span class="k">def</span> <span class="nf">write_parquet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;overwrite&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Write the StringIndex to Parquet file.</span>

<span class="sd">        :param path: str, the path to the Parquet file. Note that the col_name</span>
<span class="sd">               will be used as basename of the Parquet file.</span>
<span class="sd">        :param mode: str. One of &quot;append&quot;, &quot;overwrite&quot;, &quot;error&quot; or &quot;ignore&quot;.</span>
<span class="sd">               append: Append the contents of this StringIndex to the existing data.</span>
<span class="sd">               overwrite: Overwrite the existing data.</span>
<span class="sd">               error: Throw an exception if the data already exists.</span>
<span class="sd">               ignore: Silently ignore this operation if the data already exists.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">path</span> <span class="o">+</span> <span class="s2">&quot;/&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">col_name</span> <span class="o">+</span> <span class="s2">&quot;.parquet&quot;</span>
        <span class="n">write_parquet</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="p">)</span></div>

<div class="viewcode-block" id="StringIndex.cast"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.StringIndex.cast">[docs]</a>    <span class="k">def</span> <span class="nf">cast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="p">):</span>
        <span class="n">df_cast</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">cast</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">StringIndex</span><span class="p">(</span><span class="n">df_cast</span><span class="o">.</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">col_name</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="TargetCode"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.TargetCode">[docs]</a><span class="k">class</span> <span class="nc">TargetCode</span><span class="p">(</span><span class="n">Table</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">cat_col</span><span class="p">,</span> <span class="n">out_target_mean</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Target Encoding output used for encoding new FeatureTables, which consists of the encoded</span>
<span class="sd">        categorical column or column group and the target encoded columns (mean statistics of</span>
<span class="sd">        the categorical column or column group).</span>

<span class="sd">        :param df: Target encoded data.</span>
<span class="sd">        :param cat_col: str or list of str. The categorical column or column group encoded in the</span>
<span class="sd">               original FeatureTable.</span>
<span class="sd">        :param out_target_mean: dict, the key is the target encoded output column in this</span>
<span class="sd">               TargetCode, and the value is a tuple of the target column in the original</span>
<span class="sd">               FeatureTable together with the target column&#39;s global mean in the original</span>
<span class="sd">               FeatureTable.</span>
<span class="sd">               For example: {&quot;col3_te_target1&quot;: (&quot;target1&quot;, 3.0)}, and in this case cat_col for this</span>
<span class="sd">               TargetCode should be &quot;col3&quot;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cat_col</span> <span class="o">=</span> <span class="n">cat_col</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">out_target_mean</span> <span class="o">=</span> <span class="n">out_target_mean</span>

        <span class="n">check_col_str_list_exists</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">cat_col</span><span class="p">,</span> <span class="s2">&quot;cat_col&quot;</span><span class="p">)</span>

        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">out_target_mean</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span> <span class="s2">&quot;out_target_mean should be dict&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_clone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">TargetCode</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_col</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_target_mean</span><span class="p">)</span>

<div class="viewcode-block" id="TargetCode.rename"><a class="viewcode-back" href="../../../../doc/PythonAPI/Friesian/feature.html#bigdl.friesian.feature.table.TargetCode.rename">[docs]</a>    <span class="k">def</span> <span class="nf">rename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">columns</span><span class="p">):</span>
        <span class="n">invalidInputError</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">columns</span><span class="p">,</span> <span class="nb">dict</span><span class="p">),</span>
                          <span class="s2">&quot;columns should be a dictionary of &quot;</span>
                          <span class="s2">&quot;{&#39;old_name1&#39;: &#39;new_name1&#39;, &#39;old_name2&#39;: &#39;new_name2&#39;}&quot;</span><span class="p">)</span>
        <span class="n">new_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">df</span>
        <span class="n">new_cat_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_col</span>
        <span class="n">new_out_target_mean</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_target_mean</span>
        <span class="k">for</span> <span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="n">columns</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">new_df</span> <span class="o">=</span> <span class="n">new_df</span><span class="o">.</span><span class="n">withColumnRenamed</span><span class="p">(</span><span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cat_col</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">old_name</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_col</span><span class="p">:</span>
                <span class="n">new_cat_col</span> <span class="o">=</span> <span class="n">new_name</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cat_col</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cat_col</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cat_col</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">old_name</span><span class="p">:</span>
                        <span class="n">new_cat_col</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_name</span>
            <span class="k">elif</span> <span class="n">old_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">out_target_mean</span><span class="p">:</span>
                <span class="n">new_out_target_mean</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_out_target_mean</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">old_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">TargetCode</span><span class="p">(</span><span class="n">new_df</span><span class="p">,</span> <span class="n">new_cat_col</span><span class="p">,</span> <span class="n">new_out_target_mean</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, BigDL Authors.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>